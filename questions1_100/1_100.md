# letcode刷题(1_100)

## 1. z字形变换

Python:
```Python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows < 2: return s
        res = ["" for _ in range(numRows)]
        i, flag = 0, -1
        for c in s:
            res[i] += c
            # 到转折点取反
            if i == 0 or i == numRows - 1:
                flag = -flag
            i += flag  # 遍历行索引
        return "".join(res)
```

Rust:
```Rust
impl Solution {
    pub fn convert(s: String, num_rows: i32) -> String {
        if (num_rows < 2) {
            return s;
        }
        let mut res = vec![String::new(); num_rows as usize];
        let mut i = 0;
        let mut flag = -1;

        for c in s.chars() {
            res[i as usize].push(c);
            if i == 0 || i == num_rows - 1 {
                flag = -flag;
            }
            i += flag;
        }
    
        res.concat()
    }
}
```

## 2. 整数取反

Python:
```Python
class Solution:
    def reverse(self, x: int) -> int:
        INT_MIN, INT_MAX = -2**31, 2**31 - 1
        
        rev = 0
        while x!= 0:
            # INT_MIN 也是一个负数， 不能写成 rev < INT_MIN // 10
            if rev < INT_MIN // 10 + 1 or rev > INT_MAX // 10:
                return 0
            
            digit = x % 10

            # Python3 的取模运算在 x 为负数时也会返回 [0, 9) 以内的结果，因此这里需要进行特殊判断
            if x < 0 and digit > 0:
                digit -= 10
            
            # 同理，Python3 的整数除法在 x 为负数时会向下（更小的负数）取整，因此不能写成 x //= 10
            x = (x - digit) // 10
            rev = rev * 10 + digit
        
        return rev
```

Rust:
```Rust
impl Solution {
    pub fn reverse(x: i32) -> i32 {
        let mut x = x;
        let mut reversed = 0;

        while x != 0 {
            let last_digit = x % 10;
            x /= 10;

            // 检查溢出
            if reversed > i32::MAX / 10 || (reversed == i32::MAX / 10 && last_digit > 7) {
                return 0;
            }
            if reversed < i32::MIN / 10 || (reversed == i32::MIN / 10 && last_digit < -8) {
                return 0;
            }

            reversed = reversed * 10 + last_digit;
        }

        reversed
    }
}
```

## 3. 字符串转换整数

Python:
```Python
        s = s.strip()                      # 删除首尾空格
        if not s: return 0                   # 字符串为空则直接返回
        res, i, sign = 0, 1, 1
        int_max, int_min, bndry = 2 ** 31 - 1, -2 ** 31, 2 ** 31 // 10
        if s[0] == '-': sign = -1            # 保存负号
        elif s[0] != '+': i = 0              # 若无符号位，则需从 i = 0 开始数字拼接
        for c in s[i:]:
            if not '0' <= c <= '9' : break     # 遇到非数字的字符则跳出
            if res > bndry or res == bndry and c > '7': return int_max if sign == 1 else int_min # 数字越界处理
            res = 10 * res + ord(c) - ord('0') # 数字拼接
        return sign * res
```

Rust:
```Rust
impl Solution {
    pub fn my_atoi(s: String) -> i32 {
    let mut s = s.trim(); // 删除首尾空格
    if s.is_empty() {
        return 0; // 字符串为空则直接返回
    }

    let mut res = 0;
    let mut i = 1;
    let mut sign = 1;
    let int_max = i32::MAX;
    let int_min = i32::MIN;
    let bndry = (i32::MAX / 10) as i32;

    if s.chars().nth(0) == Some('-') {
        sign = -1; // 保存负号
    } else if s.chars().nth(0) != Some('+') {
        i = 0; // 若无符号位，则需从 i = 0 开始数字拼接
    }

    for c in s.chars().skip(i) {
        if !c.is_digit(10) {
            break; // 遇到非数字的字符则跳出
        }
        if res > bndry || (res == bndry && c.to_digit(10).unwrap() > 7) {
            return if sign == 1 { int_max } else { int_min }; // 数字越界处理
        }
        res = res * 10 + c.to_digit(10).unwrap() as i32; // 数字拼接
    }

    sign * res
    }
}
```

## 4. 回文数

Python:
```Python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # x = str(x)
        # if x[:] == x[::-1]:
        #     return True
        # else:
        #     return False

        # 反转一半的数字
        if x < 0 or (x % 10 == 0 and x != 0):
            return False

        reve = 0
        while x > reve:
            reve = reve * 10 + x % 10
            x = x // 10

        print(x)
        print(reve)

        return True if x == reve or x == reve // 10 else False
```

```Rust
impl Solution {
    pub fn is_palindrome(x: i32) -> bool {
        let mut x = x;
        if x < 0 || (x % 10 == 0 && x != 0) {
            return false
        }

        let mut reve = 0;
        while x > reve {
            reve = reve * 10 + x % 10;
            x = x / 10;
        }

        if x == reve || x == reve / 10 {
            return true
        } else {
            return false
        }
    }
}
```

## 5. 正则表达式匹配

Python:
```Python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)

        def matches(i: int, j: int) -> bool:
            if i == 0:
                return False
            if p[j - 1] == '.':
                return True
            
            return s[i-1] == p[j-1]
        
        f = [[False] * (n + 1) for _ in range(m + 1)]

        f[0][0] = True
        
        for i in range(m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    f[i][j] |= f[i][j-2]
                    if matches(i, j - 1):
                        f[i][j] |= f[i-1][j]
                else:
                    if matches(i, j):
                        f[i][j] |= f[i-1][j-1]
        return f[m][n]
```

Rust:
```Rust
impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        let m = s.len();
        let n = p.len();
        let mut f = vec![vec![false; n + 1]; m + 1];
    
        f[0][0] = true;
    
        for i in 0..=m {
            for j in 1..=n {
                if p.chars().nth(j - 1) == Some('*') {
                    f[i][j] |= f[i][j - 2];
                    if matches(&s, &p, i, j - 1) {
                        f[i][j] |= f[i - 1][j];
                    }
                } else {
                    if matches(&s, &p, i, j) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        f[m][n]
    }
}

pub fn matches(s: &str, p: &str, i: usize, j: usize) -> bool {
    if i == 0 {
        return false;
    }
    if p.chars().nth(j - 1) == Some('.') {
        return true;
    }
    s.chars().nth(i-1) == p.chars().nth(j-1)
}
```

## 6. 盛最多水的容器

Python:
```Python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 双指针指，移动短板
        left = 0
        right = len(height) - 1
        s = 0

        while left < right:
            min_height = min(height[left], height[right])  # 寻找短板
            
            if s < min_height * (right - left):
                s = min_height * (right - left)
            
            # 移动短板, 寻找较高的木板
            if height[left] > height[right]:
                right -= 1
            else:
                left += 1
        
        return s
```

Rust:
```Rust
impl Solution {
    pub fn max_area(height: Vec<i32>) -> i32 {
        // 双指指针, 移动短板
        let mut left = 0;
        let mut right = height.len() as i32 - 1;
        let mut s = 0;

        while left < right {
            // 寻找短板
            let mut min_height = height[left as usize].min(height[right as usize]);

            if s < min_height * (right - left) {
                s = min_height * (right - left);
            }

            // 移动短板，寻找较高的木板
            if height[left as usize] > height[right as usize] {
                right -= 1;
            } else {
                left += 1;
            }
        }

        s
    }
}
```

## 7. 整数转换罗马数字

Python:
```Python
class Solution:
    def intToRoman(self, num: int) -> str:
        """
        整数转换罗马数字
        :param num: 整数
        :return: 罗马数字字符串
        """
        res = ''

        hashmap = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}

        for key in hashmap:
            if num // key != 0:
                count = num // key
                res += hashmap[key] * count
                num %= key
        
        return res
```

Rust:
```Rust
impl Solution {
    pub fn int_to_roman(num: i32) -> String {
        let mut num = num;
        let mut res = String::new();
        let hashmap = [
            (1000, "M"), (900, "CM"), (500, "D"), (400, "CD"),
            (100, "C"), (90, "XC"), (50, "L"), (40, "XL"),
            (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")
        ];

        for &(key, value) in &hashmap{
            if num / key != 0 {
                let count = num / key;
                res.push_str(&value.repeat(count as usize));
                num %= key;
            }
        }

        res
    }
}
```

## 8. 罗马数字转整数

Python:
```Python
class Solution:
    def romanToInt(self, s: str) -> int:
        """
        罗马数字转整数
        :param s:
        :return:
        """
        d = {'I': 1, 'IV': 3, 'V': 5, 'IX': 8, 'X': 10, 'XL': 30, 'L': 50, 'XC': 80, 'C': 100, 'CD': 300,
                       'D': 500, 'CM': 800, 'M': 1000}
        # res = 0

        # for i, n in enumerate(s):
        #     # s[max(i - 1, 0):i + 1] -> 前一个字符与当前字符组成的字符串
        #     # n -> 当前字符
        #     num = hashmap.get(s[max(i - 1, 0):i + 1], hashmap[n])
        #     res += num
        # return res

        # 简约版
        return sum(d.get(s[max(i-1,0):i+1], d[n]) for i, n in enumerate(s))
```

Rust:
```Rust
use std::collections::HashMap;
impl Solution {
    pub fn roman_to_int(s: String) -> i32 {
        let mut hashmap = HashMap::new();
        hashmap.insert("I", 1);
        hashmap.insert("IV", 3);
        hashmap.insert("V", 5);
        hashmap.insert("IX", 8);
        hashmap.insert("X", 10);
        hashmap.insert("XL", 30);
        hashmap.insert("L", 50);
        hashmap.insert("XC", 80);
        hashmap.insert("C", 100);
        hashmap.insert("CD", 300);
        hashmap.insert("D", 500);
        hashmap.insert("CM", 800);
        hashmap.insert("M", 1000);

        let mut res = 0;
        let chars: Vec<char> = s.chars().collect();

        for i in 0..s.len() {
            let num = if i > 0 && hashmap.contains_key(&s[i - 1..=i]) {
                hashmap[&s[i - 1..=i]]
            } else {
                hashmap[&chars[i].to_string()]
            };
            res += num;
        }

        res
    }
}
```

## 9. 最长公共前缀

Python:
```Python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        # 横向扫描法
        # if not strs:
        #     return ""

        # prefix, length = strs[0], len(strs[0])
        # for i in range(1, len(strs)):
        #     prefix = self.lcp(prefix, strs[i])
        #     if not prefix:
        #         break

        # return prefix

        # 纵向扫描
        # if not strs:
        #     return ""
        
        # length, count = len(strs[0]), len(strs)

        # for i in range(length):
        #     c = strs[0][i]
        #     if any(i == len(strs[j]) or c != strs[j][i] for j in range(1, count)):
        #         return strs[0][:i]
        
        # return strs[0]

        # 分治法
        def lcp(start, end):
            if start == end:
                return strs[start]
            
            mid = (start + end) // 2
            lcpLeft, lcpRight = lcp(start, mid), lcp(mid + 1, end)  # 左边最长公共前缀、右边最长公共前缀
            minLength = min(len(lcpLeft), len(lcpRight))
            for i in range(minLength):
                if lcpLeft[i] != lcpRight[i]:
                    return lcpLeft[:i]
            
            return lcpLeft[:minLength]
        
        return "" if not strs else lcp(0, len(strs) - 1)

    # def lcp(self, str1, str2):
    #     length, index = min(len(str1), len(str2)), 0
    #     while index < length and str1[index] == str2[index]:
    #         index += 1
    #     return str1[:index]
```

Rust:
```Rust
impl Solution {
    pub fn longest_common_prefix(strs: Vec<String>) -> String {
        // 横向扫描
        // if strs.is_empty() {
        //     return String::new()
        // }
        // let mut prefix = &strs[0][..];
        // for str in &strs[1..] {
        //     prefix = Solution::lcp(prefix, str);
        //     if prefix.is_empty() {
        //         break
        //     }
        // }
        // prefix.to_string()

        // 纵向扫描
        // if strs.len() == 0 || strs.is_empty() {
        //     return String::new();
        // }
        // let lenght = strs[0].len();
        // let count = strs.len();
        // for i in 0..lenght {
        //     let c = strs[0].chars().nth(i);
        //     for j in 1..count {
        //         if i == strs[j].len() || c != strs[j].chars().nth(i) {
        //             return strs[0][..i].to_string();
        //         }
        //     }
        // }
        // strs[0][..].to_string()

        // 分治法 (报错: thread 'main' has overflowed its stack (solution.rs))
        fn lcp(strs: &Vec<String>, start: usize, end: usize) -> String {
            if start == end {
                return strs[start][..].to_string();
            }
    
            let mid = (start + end) / 2;
            let lcpLeft = lcp(strs, start, mid);  // 左部分最长公共前缀
            let lcpRight = lcp(strs, start, mid + 1);  // 右部分最长公共前缀
            let minLength = lcpLeft.len().min(lcpRight.len());
    
            for i in 0..minLength {
                if lcpLeft.chars().nth(i) != lcpRight.chars().nth(i) {
                    return lcpLeft[..i].to_string();
                }
            }
    
            return lcpLeft[..minLength].to_string();
        }


        if strs.is_empty() {
            return String::new();
        } else {
            lcp(&strs, 0, strs.len() - 1)[..].to_string()
        }
    }

    // pub fn lcp<'a>(str1: &'a str, str2: &'a str) -> &'a str {
    //     let lenght = str1.len().min(str2.len());
    //     let mut index = 0;
    //     while index < lenght && str1.chars().nth(index) == str2.chars().nth(index) {
    //         index += 1;
    //     }
    //     &str1[..index]
    // }

}
```

## 10. 三数之和

解题思路:

![image](https://github.com/user-attachments/assets/fb65b16d-077e-4083-aaed-ebdc9bcb37b0)

Python:
```Pyhton
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        """
        排序 + 双指针
        """
        num.sort()
        res, k = [], 0
        for k in range(len(nums) - 2):
            if nums[k] > 0: break  # 当nums[k]元素 > 0, 说明已经没有 三数之和=0            
            if k > 0 and num[k] == num [k-1]: continue  # 跳过已经遍历过的元素
            i, j = k + 1, len(nums) - 1

            while i < j:
                s = nums[k] + nums[i] + nums[j]
                if s < 0:
                    i += 1
                    while i < j and nums[i] = nums[i - 1]: i += 1
                elif s > 0:
                    j -= 1
                    while i < j and num[j] == nums[j + 1]: j -= 1
                else:
                    res.append([nums[k], nums[i], nums[j]])
                    i += 1
                    j -= 1
                    while i < j and nums[i] = nums[i - 1]: i += 1
                    while i < j and num[j] == nums[j + 1]: j -= 1
        return res
```
