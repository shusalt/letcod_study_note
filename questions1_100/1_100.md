# letcode刷题(1_100)

## 1. z字形变换

Python:
```Python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows < 2: return s
        res = ["" for _ in range(numRows)]
        i, flag = 0, -1
        for c in s:
            res[i] += c
            # 到转折点取反
            if i == 0 or i == numRows - 1:
                flag = -flag
            i += flag  # 遍历行索引
        return "".join(res)
```

Rust:
```Rust
impl Solution {
    pub fn convert(s: String, num_rows: i32) -> String {
        if (num_rows < 2) {
            return s;
        }
        let mut res = vec![String::new(); num_rows as usize];
        let mut i = 0;
        let mut flag = -1;

        for c in s.chars() {
            res[i as usize].push(c);
            if i == 0 || i == num_rows - 1 {
                flag = -flag;
            }
            i += flag;
        }
    
        res.concat()
    }
}
```

## 2. 整数取反

Python:
```Python
class Solution:
    def reverse(self, x: int) -> int:
        INT_MIN, INT_MAX = -2**31, 2**31 - 1
        
        rev = 0
        while x!= 0:
            # INT_MIN 也是一个负数， 不能写成 rev < INT_MIN // 10
            if rev < INT_MIN // 10 + 1 or rev > INT_MAX // 10:
                return 0
            
            digit = x % 10

            # Python3 的取模运算在 x 为负数时也会返回 [0, 9) 以内的结果，因此这里需要进行特殊判断
            if x < 0 and digit > 0:
                digit -= 10
            
            # 同理，Python3 的整数除法在 x 为负数时会向下（更小的负数）取整，因此不能写成 x //= 10
            x = (x - digit) // 10
            rev = rev * 10 + digit
        
        return rev
```

Rust:
```Rust
impl Solution {
    pub fn reverse(x: i32) -> i32 {
        let mut x = x;
        let mut reversed = 0;

        while x != 0 {
            let last_digit = x % 10;
            x /= 10;

            // 检查溢出
            if reversed > i32::MAX / 10 || (reversed == i32::MAX / 10 && last_digit > 7) {
                return 0;
            }
            if reversed < i32::MIN / 10 || (reversed == i32::MIN / 10 && last_digit < -8) {
                return 0;
            }

            reversed = reversed * 10 + last_digit;
        }

        reversed
    }
}
```

## 3. 字符串转换整数

Python:
```Python
        s = s.strip()                      # 删除首尾空格
        if not s: return 0                   # 字符串为空则直接返回
        res, i, sign = 0, 1, 1
        int_max, int_min, bndry = 2 ** 31 - 1, -2 ** 31, 2 ** 31 // 10
        if s[0] == '-': sign = -1            # 保存负号
        elif s[0] != '+': i = 0              # 若无符号位，则需从 i = 0 开始数字拼接
        for c in s[i:]:
            if not '0' <= c <= '9' : break     # 遇到非数字的字符则跳出
            if res > bndry or res == bndry and c > '7': return int_max if sign == 1 else int_min # 数字越界处理
            res = 10 * res + ord(c) - ord('0') # 数字拼接
        return sign * res
```

Rust:
```Rust
impl Solution {
    pub fn my_atoi(s: String) -> i32 {
    let mut s = s.trim(); // 删除首尾空格
    if s.is_empty() {
        return 0; // 字符串为空则直接返回
    }

    let mut res = 0;
    let mut i = 1;
    let mut sign = 1;
    let int_max = i32::MAX;
    let int_min = i32::MIN;
    let bndry = (i32::MAX / 10) as i32;

    if s.chars().nth(0) == Some('-') {
        sign = -1; // 保存负号
    } else if s.chars().nth(0) != Some('+') {
        i = 0; // 若无符号位，则需从 i = 0 开始数字拼接
    }

    for c in s.chars().skip(i) {
        if !c.is_digit(10) {
            break; // 遇到非数字的字符则跳出
        }
        if res > bndry || (res == bndry && c.to_digit(10).unwrap() > 7) {
            return if sign == 1 { int_max } else { int_min }; // 数字越界处理
        }
        res = res * 10 + c.to_digit(10).unwrap() as i32; // 数字拼接
    }

    sign * res
    }
}
```

## 4. 回文数

Python:
```Python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # x = str(x)
        # if x[:] == x[::-1]:
        #     return True
        # else:
        #     return False

        # 反转一半的数字
        if x < 0 or (x % 10 == 0 and x != 0):
            return False

        reve = 0
        while x > reve:
            reve = reve * 10 + x % 10
            x = x // 10

        print(x)
        print(reve)

        return True if x == reve or x == reve // 10 else False
```

```Rust
impl Solution {
    pub fn is_palindrome(x: i32) -> bool {
        let mut x = x;
        if x < 0 || (x % 10 == 0 && x != 0) {
            return false
        }

        let mut reve = 0;
        while x > reve {
            reve = reve * 10 + x % 10;
            x = x / 10;
        }

        if x == reve || x == reve / 10 {
            return true
        } else {
            return false
        }
    }
}
```

## 5. 正则表达式匹配

Python:
```Python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)

        def matches(i: int, j: int) -> bool:
            if i == 0:
                return False
            if p[j - 1] == '.':
                return True
            
            return s[i-1] == p[j-1]
        
        f = [[False] * (n + 1) for _ in range(m + 1)]

        f[0][0] = True
        
        for i in range(m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    f[i][j] |= f[i][j-2]
                    if matches(i, j - 1):
                        f[i][j] |= f[i-1][j]
                else:
                    if matches(i, j):
                        f[i][j] |= f[i-1][j-1]
        return f[m][n]
```

Rust:
```Rust
impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        let m = s.len();
        let n = p.len();
        let mut f = vec![vec![false; n + 1]; m + 1];
    
        f[0][0] = true;
    
        for i in 0..=m {
            for j in 1..=n {
                if p.chars().nth(j - 1) == Some('*') {
                    f[i][j] |= f[i][j - 2];
                    if matches(&s, &p, i, j - 1) {
                        f[i][j] |= f[i - 1][j];
                    }
                } else {
                    if matches(&s, &p, i, j) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        f[m][n]
    }
}

pub fn matches(s: &str, p: &str, i: usize, j: usize) -> bool {
    if i == 0 {
        return false;
    }
    if p.chars().nth(j - 1) == Some('.') {
        return true;
    }
    s.chars().nth(i-1) == p.chars().nth(j-1)
}
```

## 6. 盛最多水的容器

Python:
```Python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 双指针指，移动短板
        left = 0
        right = len(height) - 1
        s = 0

        while left < right:
            min_height = min(height[left], height[right])  # 寻找短板
            
            if s < min_height * (right - left):
                s = min_height * (right - left)
            
            # 移动短板, 寻找较高的木板
            if height[left] > height[right]:
                right -= 1
            else:
                left += 1
        
        return s
```

Rust:
```Rust
impl Solution {
    pub fn max_area(height: Vec<i32>) -> i32 {
        // 双指指针, 移动短板
        let mut left = 0;
        let mut right = height.len() as i32 - 1;
        let mut s = 0;

        while left < right {
            // 寻找短板
            let mut min_height = height[left as usize].min(height[right as usize]);

            if s < min_height * (right - left) {
                s = min_height * (right - left);
            }

            // 移动短板，寻找较高的木板
            if height[left as usize] > height[right as usize] {
                right -= 1;
            } else {
                left += 1;
            }
        }

        s
    }
}
```

## 7. 整数转换罗马数字

Python:
```Python
class Solution:
    def intToRoman(self, num: int) -> str:
        """
        整数转换罗马数字
        :param num: 整数
        :return: 罗马数字字符串
        """
        res = ''

        hashmap = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}

        for key in hashmap:
            if num // key != 0:
                count = num // key
                res += hashmap[key] * count
                num %= key
        
        return res
```

Rust:
```Rust
impl Solution {
    pub fn int_to_roman(num: i32) -> String {
        let mut num = num;
        let mut res = String::new();
        let hashmap = [
            (1000, "M"), (900, "CM"), (500, "D"), (400, "CD"),
            (100, "C"), (90, "XC"), (50, "L"), (40, "XL"),
            (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")
        ];

        for &(key, value) in &hashmap{
            if num / key != 0 {
                let count = num / key;
                res.push_str(&value.repeat(count as usize));
                num %= key;
            }
        }

        res
    }
}
```

## 8. 罗马数字转整数

Python:
```Python
class Solution:
    def romanToInt(self, s: str) -> int:
        """
        罗马数字转整数
        :param s:
        :return:
        """
        d = {'I': 1, 'IV': 3, 'V': 5, 'IX': 8, 'X': 10, 'XL': 30, 'L': 50, 'XC': 80, 'C': 100, 'CD': 300,
                       'D': 500, 'CM': 800, 'M': 1000}
        # res = 0

        # for i, n in enumerate(s):
        #     # s[max(i - 1, 0):i + 1] -> 前一个字符与当前字符组成的字符串
        #     # n -> 当前字符
        #     num = hashmap.get(s[max(i - 1, 0):i + 1], hashmap[n])
        #     res += num
        # return res

        # 简约版
        return sum(d.get(s[max(i-1,0):i+1], d[n]) for i, n in enumerate(s))
```

Rust:
```Rust
use std::collections::HashMap;
impl Solution {
    pub fn roman_to_int(s: String) -> i32 {
        let mut hashmap = HashMap::new();
        hashmap.insert("I", 1);
        hashmap.insert("IV", 3);
        hashmap.insert("V", 5);
        hashmap.insert("IX", 8);
        hashmap.insert("X", 10);
        hashmap.insert("XL", 30);
        hashmap.insert("L", 50);
        hashmap.insert("XC", 80);
        hashmap.insert("C", 100);
        hashmap.insert("CD", 300);
        hashmap.insert("D", 500);
        hashmap.insert("CM", 800);
        hashmap.insert("M", 1000);

        let mut res = 0;
        let chars: Vec<char> = s.chars().collect();

        for i in 0..s.len() {
            let num = if i > 0 && hashmap.contains_key(&s[i - 1..=i]) {
                hashmap[&s[i - 1..=i]]
            } else {
                hashmap[&chars[i].to_string()]
            };
            res += num;
        }

        res
    }
}
```

## 9. 最长公共前缀

Python:
```Python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        # 横向扫描法
        # if not strs:
        #     return ""

        # prefix, length = strs[0], len(strs[0])
        # for i in range(1, len(strs)):
        #     prefix = self.lcp(prefix, strs[i])
        #     if not prefix:
        #         break

        # return prefix

        # 纵向扫描
        # if not strs:
        #     return ""
        
        # length, count = len(strs[0]), len(strs)

        # for i in range(length):
        #     c = strs[0][i]
        #     if any(i == len(strs[j]) or c != strs[j][i] for j in range(1, count)):
        #         return strs[0][:i]
        
        # return strs[0]

        # 分治法
        def lcp(start, end):
            if start == end:
                return strs[start]
            
            mid = (start + end) // 2
            lcpLeft, lcpRight = lcp(start, mid), lcp(mid + 1, end)  # 左边最长公共前缀、右边最长公共前缀
            minLength = min(len(lcpLeft), len(lcpRight))
            for i in range(minLength):
                if lcpLeft[i] != lcpRight[i]:
                    return lcpLeft[:i]
            
            return lcpLeft[:minLength]
        
        return "" if not strs else lcp(0, len(strs) - 1)

    # def lcp(self, str1, str2):
    #     length, index = min(len(str1), len(str2)), 0
    #     while index < length and str1[index] == str2[index]:
    #         index += 1
    #     return str1[:index]
```

Rust:
```Rust
impl Solution {
    pub fn longest_common_prefix(strs: Vec<String>) -> String {
        // 横向扫描
        // if strs.is_empty() {
        //     return String::new()
        // }
        // let mut prefix = &strs[0][..];
        // for str in &strs[1..] {
        //     prefix = Solution::lcp(prefix, str);
        //     if prefix.is_empty() {
        //         break
        //     }
        // }
        // prefix.to_string()

        // 纵向扫描
        // if strs.len() == 0 || strs.is_empty() {
        //     return String::new();
        // }
        // let lenght = strs[0].len();
        // let count = strs.len();
        // for i in 0..lenght {
        //     let c = strs[0].chars().nth(i);
        //     for j in 1..count {
        //         if i == strs[j].len() || c != strs[j].chars().nth(i) {
        //             return strs[0][..i].to_string();
        //         }
        //     }
        // }
        // strs[0][..].to_string()

        // 分治法 (报错: thread 'main' has overflowed its stack (solution.rs))
        fn lcp(strs: &Vec<String>, start: usize, end: usize) -> String {
            if start == end {
                return strs[start][..].to_string();
            }
    
            let mid = (start + end) / 2;
            let lcpLeft = lcp(strs, start, mid);  // 左部分最长公共前缀
            let lcpRight = lcp(strs, start, mid + 1);  // 右部分最长公共前缀
            let minLength = lcpLeft.len().min(lcpRight.len());
    
            for i in 0..minLength {
                if lcpLeft.chars().nth(i) != lcpRight.chars().nth(i) {
                    return lcpLeft[..i].to_string();
                }
            }
    
            return lcpLeft[..minLength].to_string();
        }


        if strs.is_empty() {
            return String::new();
        } else {
            lcp(&strs, 0, strs.len() - 1)[..].to_string()
        }
    }

    // pub fn lcp<'a>(str1: &'a str, str2: &'a str) -> &'a str {
    //     let lenght = str1.len().min(str2.len());
    //     let mut index = 0;
    //     while index < lenght && str1.chars().nth(index) == str2.chars().nth(index) {
    //         index += 1;
    //     }
    //     &str1[..index]
    // }

}
```

## 10. 三数之和

解题思路:

![image](./graph/Snipaste_2024-10-17_10-38-59.png)

Python:
```Pyhton
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        """
        排序 + 双指针
        """
        num.sort()
        res, k = [], 0
        for k in range(len(nums) - 2):
            if nums[k] > 0: break  # 当nums[k]元素 > 0, 说明已经没有 三数之和=0            
            if k > 0 and num[k] == num [k-1]: continue  # 跳过已经遍历过的元素
            i, j = k + 1, len(nums) - 1

            while i < j:
                s = nums[k] + nums[i] + nums[j]
                if s < 0:
                    i += 1
                    while i < j and nums[i] = nums[i - 1]: i += 1
                elif s > 0:
                    j -= 1
                    while i < j and num[j] == nums[j + 1]: j -= 1
                else:
                    res.append([nums[k], nums[i], nums[j]])
                    i += 1
                    j -= 1
                    while i < j and nums[i] = nums[i - 1]: i += 1
                    while i < j and num[j] == nums[j + 1]: j -= 1
        return res
```

Rust:
```Rust
use std::collections::HashSet;

impl Solution {
    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut nums = nums;
        nums.sort();
        let mut res = HashSet::new();
        let mut k = 0;
        for k in 0..nums.len()-2 {
            if nums[k] > 0 { break; }
            if k > 0 && nums[k] == nums[k-1] { continue; }
            let mut i = k + 1;
            let mut j = nums.len() - 1;
            while i < j {
                let mut s = nums[k] + nums[i] + nums[j];
                if s < 0 {
                    i += 1;
                    while i < j && nums[i] == nums[i-1] { i += 1; }
                } else if s > 0 {
                    j -= 1;
                    while i < j && nums[j] == nums[j+1] { j -= 1; }
                } else {
                    res.insert(vec![nums[k], nums[i], nums[j]]);
                    i += 1;
                    j -= 1;
                    while i < j && nums[i] == nums[i-1] { i += 1; }
                    while i < j && nums[j] == nums[j+1] { j -= 1; }
                }
            }
        }

        res.into_iter().collect()
    }
}
```

## 11. 最接近的三数之和

![image](https://github.com/user-attachments/assets/2b7fb8f9-61cb-4d22-9073-64de276bd83b)


Python
```Python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums_len = len(nums)
        nums.sort()
        res = (nums[nums_len - 1] + nums[nums_len - 2] + nums[nums_len - 3])
        for k in range(len(nums) - 2):
            start, end = k + 1, len(nums) - 1
            while start < end:
                cur = nums[k] + nums[start] + nums[end]
                if cur < target:
                    start += 1
                    while start < end and nums[start] == nums[start - 1]: start += 1
                elif cur > target:
                    end -= 1
                    while start < end and nums[end] == nums[end + 1]: end -= 1
                elif cur == target:
                    return cur

                res = res if abs(target - cur) > abs(target - res) else cur

        return res
```

Rust:
```Rust
impl Solution {
    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {
        /*
        最接近的三数之和
         */
        let mut nums = nums;
        nums.sort();
        let nums_len = nums.len();
        let mut res = nums[nums_len - 1] + nums[nums_len - 2] + nums[nums_len - 3];
        for k in 0..nums_len - 2 {
            let mut i = k + 1;
            let mut j = nums_len - 1;
            while i < j {
                let cur = nums[k] + nums[i] + nums[j];
                if cur < target {
                    i += 1;
                    while i < j && nums[i] == nums[i - 1] { i += 1;}
                } else if cur > target {
                    j -= 1;
                    while i < j && nums[j] == nums[j + 1] {j -= 1;}
                } else if cur == target {
                    return cur
                }
                if (target - cur).abs() < (target - res).abs() { res = cur; }
            }
        }
        return res     
    }
}
```

## 12. 电话号码的字母组合

![image](https://github.com/user-attachments/assets/e3753f21-8a11-4ca1-9606-53ec154bfcbd)

![image](https://github.com/user-attachments/assets/47dbd05f-080c-4d94-9d77-f2901b224454)

Python:
```Python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return list()

        # 定义一个号码与字母的映射
        num_to_chs = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }
    
        def backrack(index):
            if index == len(digits):
                res.append(''.join(com))
            else:
                num = digits[index]
                chs = num_to_chs[num]
                for ch in chs:
                    com.append(ch)
                    backrack(index + 1)  # 递归
                    com.pop()  # 回溯
        
        com = list()
        res = list()
        backrack(0)

        return res
```

Rust:
```Rust
use std::collections::HashMap;
use std::slice::Iter;
impl Solution {
    pub fn letter_combinations(digits: String) -> Vec<String> {
        if digits.is_empty() {
            return vec![];
        }

        // 定义一个号码与字母的映射
        let num_to_chs: HashMap<char, &'static str> = [
            ('2', "abc"),
            ('3', "def"),
            ('4', "ghi"),
            ('5', "jkl"),
            ('6', "mno"),
            ('7', "pqrs"),
            ('8', "tuv"),
            ('9', "wxyz"),
        ].iter().cloned().collect();

        let mut res = Vec::new();
        let mut com = String::new();
        Solution::backtrack(&digits, 0, &num_to_chs, &mut com, &mut res);
        res
    }

    fn backtrack(
        digits: &str,
        index: usize,
        num_to_chs: &HashMap<char, &'static str>,
        com: &mut String,
        res: &mut Vec<String>,
    ) {
        if index == digits.len() {
            res.push(com.clone());
        } else {
            let num = digits.chars().nth(index).unwrap();
            if let Some(chs) = num_to_chs.get(&num) {
                for ch in chs.chars() {
                    com.push(ch);
                    Solution::backtrack(digits, index + 1, num_to_chs, com, res);  // 递归
                    com.pop();  // 回溯
                }
            }
        }
    }
}
```

## 13 四数之和

![image](https://github.com/user-attachments/assets/cf906c10-702a-4c72-a58e-6e898d30c43e)

![image](https://github.com/user-attachments/assets/07026777-cda6-46a9-a7c3-454c4509e567)

Pyhton:
```Python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        """
        四数之和
        :param nums:
        :param target:
        :return:
        """
        nums.sort()
        ans = []
        n = len(nums)
        for a in range(n - 3):  # 枚举第二个数
            x = nums[a]
            if a and x == nums[a - 1]:  # 跳过重复数据
                continue
            if x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target:  # 优化一
                continue
            if x + nums[-1] + nums[-2] + nums[-3] < target:  # 优化二
                continue

            for b in range(a + 1, n - 2):  # 枚举第二个数
                y = nums[b]
                if b > a + 1 and y == nums[b - 1]:  # 跳过重复数字
                    continue
                if x + y + nums[b + 1] + nums[b + 2] > target:  # 优化三
                    continue
                if x + y + nums[-1] + nums[-2] < target:  # 优化四
                    continue

                # 双指针枚举第三个数和第四个数
                c = b + 1
                d = n - 1
                while c < d:
                    s = x + y + nums[c] + nums[d]  # 四数之和
                    if s > target:
                        d -= 1
                    elif s < target:
                        c += 1
                    else:
                        ans.append([x, y, nums[c], nums[d]])
                        c += 1
                        while c < d and nums[c] == nums[c - 1]:
                            c += 1
                        d -= 1
                        while c < d and nums[d] == nums[d + 1]:
                            d -= 1
        return ans
```

Rust:
```Rust
use std::collections::HashSet;

impl Solution {
    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        if nums.len() < 4 {
            return vec![];
        }
        let target = target as i64;
        let mut nums = nums;
        nums.sort();
        let mut ans = HashSet::new();
        let n = nums.len();

        for a in 0..n - 3 {
            let x = nums[a];
            if a > 0 && x == nums[a - 1] {
                continue;
            }
            let temp1 = (x as i64 + nums[a+1] as i64 + nums[a+2] as i64 + nums[a+3] as i64);
            if temp1 > target {
                continue;
            }
            let temp2 = (x as i64 + nums[n - 1] as i64 + nums[n - 2] as i64 + nums[n - 3] as i64 );
            if temp2 < target {
                continue;
            }
            for b in a + 1..n - 2 {
                let y = nums[b];
                if b > a + 1 && y == nums[b - 1] {
                    continue;
                }
                let temp3 = (x as i64 + y as i64 + nums[b + 1] as i64 + nums[b + 2] as i64 );
                if temp3 > target {
                    continue;
                }
                let temp4 = (x as i64 + y as i64 + nums[n - 1] as i64 + nums[n - 2] as i64 );
                if temp4 < target {
                    continue;
                }

                let mut c = b + 1;
                let mut d = n - 1;
                while c < d {
                    let s = (x as i64 + y as i64 + nums[c] as i64 + nums[d] as i64);
                    if s > target {
                        d -= 1;
                    } else if s < target {
                        c += 1;
                    } else {
                        ans.insert(vec![x, y, nums[c], nums[d]]);
                        c += 1;
                        while c < d && nums[c] == nums[c - 1] {
                            c += 1;
                        }
                        d -= 1;
                        while c < d && nums[d] == nums[d + 1] {
                            d -= 1;
                        }
                    }
                }
            }
        }

        ans.into_iter().collect()
    }
}
```

## 14 删除链表的倒数第n个节点

![image](https://github.com/user-attachments/assets/188e0872-e024-425f-a1dd-686308b1a84c)

Python:
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        """
        删除链表的倒数第n个节点
        思路：利用双指针, end指标前走n结点，然后start 和 end 共同往前走
        :param head:
        :param n:
        :return:
        """
        dummy = ListNode(0, head)
        start = dummy
        end = head

        for i in range(n):
            end = end.next
        
        while end:
            start = start.next
            end = end.next
        
        start.next = start.next.next
        return dummy.next
```

Rust:
```Rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));
        let mut slow_p = &mut dummy;
        let mut fast_p = &slow_p.clone();

        for _ in 0..=n {
            if let Some(fast_node) = fast_p {
                fast_p = &fast_node.next;
            } else {
                return None;
            }
        }

        while fast_p.is_some() {
            fast_p = &fast_p.as_ref().unwrap().next;
            slow_p = &mut slow_p.as_mut().unwrap().next;
        }

        let remove_p = &mut slow_p.as_mut().unwrap().next;
        slow_p.as_mut().unwrap().next = remove_p.as_mut().unwrap().next.take();

        dummy.unwrap().next
    }
}
```
## 15 有效的括号

![image](https://github.com/user-attachments/assets/d5d354d3-0dec-49f6-ba09-aa31584dce52)

Python:
```Python
class Solution:
    def isValid(self, s: str) -> bool:
        """
        使用栈的特性，进行解题
        遇到左括号进栈，遇到有括号(且是同一类型的括号)出栈
        :param s:
        :return:
        """
        if len(s) % 2 != 0:
            return False

        pairs = {
            ")": "(",
            "]": "[",
            "}": "{",
        }

        stack = list()
        for ch in s:
            if ch in pairs:
                if not stack or stack[-1] != pairs[ch]:
                    return False
                stack.pop()
            else:
                stack.append(ch)

        return not stack
```

Rust:
```Rust
use std::collections::HashMap;
impl Solution {
    pub fn is_valid(s: String) -> bool {
        if s.len() % 2 != 0 {
            return false;
        }

        let pairs = HashMap::from([
            (')', '('),
            (']', '['),
            ('}', '{'),
        ]);

        let mut stack = Vec::new();
        for ch in s.chars() {
            if let Some(&closing) = pairs.get(&ch) {
                if stack.is_empty() || stack.pop().unwrap() != closing {
                    return false
                }
            } else {
                stack.push(ch)
            }
        }

        stack.is_empty()
    }
}
```

## 16 两个有序链表合并

Python:
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        head = ListNode()
        temp = head

        while list1 and list2:
            if list1.val <= list2.val:
                temp.next = list1
                temp = temp.next
                list1 = list1.next
            elif list1.val > list2.val:
                temp.next = list2
                temp = temp.next
                list2 = list2.next

        while list1:
            temp.next = list1
            temp = temp.next
            list1 = list1.next

        while list2:
            temp.next = list2
            temp = temp.next
            list2 = list2.next
        
        return head.next
```


Rust:
```Rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut dummy_head = Some(Box::new(ListNode::new(0)));
        let mut temp = &mut dummy_head;

        let mut l1 = list1;
        let mut l2 = list2;

        while l1.is_some() && l2.is_some() {
            let l1_val = l1.as_ref().unwrap().val;
            let l2_val = l2.as_ref().unwrap().val;

            if l1_val <= l2_val {
                temp.as_mut().unwrap().next = l1.take();
                l1 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            } else {
                temp.as_mut().unwrap().next = l2.take();
                l2 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            }

            temp = &mut temp.as_mut().unwrap().next;
        }

        if l1.is_some() {
            temp.as_mut().unwrap().next = l1;
        } else {
            temp.as_mut().unwrap().next = l2;
        }

        dummy_head.unwrap().next
    }
}
```

## 17 括号生成

![image](https://github.com/user-attachments/assets/c561a458-d7aa-449f-ae7e-03a556589660)


Python
```Python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        """
        递归
        枚举填左括号还是右括号
        :param n:
        :return:
        """
        m = n * 2  # 括号长度
        ans = []
        path = [''] * m  # 所有括号长度都是一样的m

        # i = 目前填写了多少括号
        # open = 左括号个数，i - open = 右括号个数
        def dfs(i, open):
            if i == m:  # 括号构造完成
                ans.append(''.join(path))
                return
            if open < n:  # 可以填写左括号
                path[i] = '('  # 覆盖
                dfs(i + 1, open + 1)
            if i - open < open:
                path[i] = ')'  # 覆盖
                dfs(i + 1, open)

        dfs(0, 0)
        return ans
```

Rust:
```Rust
impl Solution {
    fn back_trace(s: String, n: usize, right: usize, left: usize, result: &mut Vec<String>) {
		if s.len() == 2 * n {
			result.push(s);
			return;
		}

		if left < n {
			let mut s = s.to_owned();
			s.push('(');
			Self::back_trace(s, n, right, left + 1, result);
		}

		if left > 0 && left > right && right < n {
			let mut s = s.to_owned();
			s.push(')');
			Self::back_trace(s, n, right + 1, left, result);
		}
	}

	pub fn generate_parenthesis(n: i32) -> Vec<String> {
		let mut result = vec![];
		Self::back_trace(String::new(), n as usize, 0, 0, &mut result);
		result
	}
}
```

## 18 合并k个有序链表

Python:
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def Merge(slef, list1, list2):
        if not list1 and not list2:
            return

        if not list1:
            return list2
        if not list2:
            return list1

        head = ListNode()
        temp = head

        while list1 and list2:
            if list1.val <= list2.val:
                temp.next = list1
                temp = temp.next
                list1 = list1.next
            elif list1.val > list2.val:
                temp.next = list2
                temp = temp.next
                list2 = list2.next

        while list1:
            temp.next = list1
            temp = temp.next
            list1 = list1.next

        while list2:
            temp.next = list2
            temp = temp.next
            list2 = list2.next
        
        return head.next

    def driverMerge(self, lists, left, right):
        if left > right:
            return None
        elif left == right:
            return lists[left]
        mid = (left + right) // 2
        left_link = self.driverMerge(lists, left, mid)
        right_link = self.driverMerge(lists, mid + 1, right)
        return self.Merge(left_link, right_link)
        
        

    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        """
        二分
        归并
        """
        return self.driverMerge(lists, 0, len(lists)-1)
```

Rust:
```Rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    fn merge(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) ->  Option<Box<ListNode>> {
        let mut dummy_head = Some(Box::new(ListNode::new(0)));
        let mut temp = &mut dummy_head;

        let mut l1 = list1;
        let mut l2 = list2;

        while l1.is_some() && l2.is_some() {
            let l1_val = l1.as_ref().unwrap().val;
            let l2_val = l2.as_ref().unwrap().val;

            if l1_val <= l2_val {
                temp.as_mut().unwrap().next = l1.take();
                l1 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            } else {
                temp.as_mut().unwrap().next = l2.take();
                l2 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            }

            temp = &mut temp.as_mut().unwrap().next;
        }

        if l1.is_some() {
            temp.as_mut().unwrap().next = l1;
        } else {
            temp.as_mut().unwrap().next = l2;
        }

        dummy_head.unwrap().next
    }

    fn derive_merge(lists: &[Option<Box<ListNode>>], left: usize, right: usize) -> Option<Box<ListNode>> {
        if left > right {
            return None;
        } else if left == right {
            return lists[left].clone();
        }
        let mid = (left + right) / 2;
        let left_link = Solution::derive_merge(lists, left, mid);
        let right_link = Solution::derive_merge(lists, mid + 1, right);
        Solution::merge(left_link, right_link)
    }

    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {
        if lists.is_empty() {
            return None;
        }
        Solution::derive_merge(&lists, 0, lists.len() - 1)
    }
}
```

## 19 两两交换链表中的节点

Python:
```Python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        循环
        """
        dummy = ListNode(next=head)  # 用哨兵节点简化代码逻辑
        node0 = dummy
        node1 = head
        while node1 and node1.next:  # 至少有两个节点
            node2 = node1.next
            node3 = node2.next

            node0.next = node2  # 0 -> 2
            node2.next = node1  # 2 -> 1
            node1.next = node3  # 1 -> 3

            node0 = node1  # 下一轮交换，0 是 1
            node1 = node3  # 下一轮交换，1 是 3
        return dummy.next  # 返回新链表的头节点

    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        递归
        """
        if head is None or head.next is None:
            return head  # 不足两个节点，无需交换
        
        node1 = head
        node2 = head.next
        node3 = node2.next

        node1.next = self.swapPairs(node3)  # 指向递归返回的链表头
        node2.next = node1  # node2 指向 node1

        return node2  # 返回交换后的链表头节点
```

Rust:
```Rust
```
