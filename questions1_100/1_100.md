# letcode刷题(1_100)

## 1 两数之和

```
数组、哈希表
```

题解：
- step1：用一个哈希表，存储遍历过的元素以及下标
- step2：遍历元素时，判断 target - cur_element 是否在 hashmap 里，在则放回相应的下标，不在存储遍历过的元素以及下标，继续往下遍历

Python:
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        idx = {}
        for j, x in enumerate(nums):
            if target - x in idx:
                return [idx[target - x], j]
            idx[x] = j
```

Rust:
```rust
use std::collections::HashMap;

impl Solution {
    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let mut idx = HashMap::new();

        for (index, &num) in nums.iter().enumerate() {
            if let Some(&i) = idx.get(&(target - num)) {
                return vec![i as i32, index as i32];
            }
            idx.insert(num, index);
        }

        unreachable!()
    }
}
```

## 2. 两个数相加:

```
递归、链表、数学
```

Python:
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        cur = dummy = ListNode()  # 哨兵模式
        carry = 0  # 进位
        while l1 or l2 or carry:
            s = carry + (l1.val if l1 else 0) + (l2.val if l2 else 0)  # 位数之和
            cur.next = ListNode(s % 10)  # 计算当前位
            carry = s // 10  # 计算进位
            cur = cur.next
            if l1: l1 = l1.next
            if l2: l2 = l2.next
        return dummy.next
```

Rust
```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut l1 = l1; // 移动所有权
        let mut l2 = l2; // 移动所有权

        let mut dummy = ListNode::new(0); // 哨兵节点
        let mut cur = &mut dummy;
        let mut carry = 0; // 进位
        while l1.is_some() || l2.is_some() || carry != 0 {
            let mut sum = carry;
            if let Some(node) = l1 {
                sum += node.val;
                l1 = node.next;
            }

            if let Some(node) = l2 {
                sum += node.val;
                l2 = node.next;
            }
            
            carry = sum / 10;
            cur.next = Some(Box::new(ListNode::new(sum % 10)));
            cur = cur.next.as_mut().unwrap();
        }
        dummy.next
    }
}
```

## 3. 无重复字符的最长子串

```
哈希表、字符串、滑动窗口
```

题解：
![image](https://github.com/user-attachments/assets/9145e212-3e05-4c97-b1d1-0662340db15b)

Python:
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 哈希集合，记录每个字符是否出现过
        occ = set()
        n = len(s)
        # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一格，移除一个字符
                occ.remove(s[i - 1])
            while rk + 1 < n and s[rk + 1] not in occ:
                # 不断地移动右指针
                occ.add(s[rk + 1])
                rk += 1
            # 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1)
        return ans
```

Rust:
```rust
use std::collections::HashSet;

impl Solution {
    pub fn length_of_longest_substring(s: String) -> i32 {
        let s = s.as_bytes();
        let mut ans = 0;
        let mut left = 0;
        let mut window = [false; 128];
        for (right, &c) in s.iter().enumerate() {
            let c = c as usize;
            // 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素
            // 所以要在加入 c 之前，先移出窗口内的 c
            while window[c] { // 窗口内有字符c
                window[s[left] as usize] = false; // 移除
                left += 1;
            }

            window[c] = true;
            ans = ans.max(right - left + 1); // 更新窗口长度最大值
        }
        ans as _
    }
}
```

## 4 寻找两个正序数组的中位数

```
数组、二分查找、分治
```

Python:
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def getKthElement(k):
            """
            - 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
            - 这里的 "/" 表示整除
            - nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
            - nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
            - 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
            - 这样 pivot 本身最大也只能是第 k-1 小的元素
            - 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
            - 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
            - 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
            """
            
            index1, index2 = 0, 0
            while True:
                # 特殊情况
                if index1 == m:
                    return nums2[index2 + k - 1]
                if index2 == n:
                    return nums1[index1 + k - 1]
                if k == 1:
                    return min(nums1[index1], nums2[index2])

                # 正常情况
                newIndex1 = min(index1 + k // 2 - 1, m - 1)
                newIndex2 = min(index2 + k // 2 - 1, n - 1)
                pivot1, pivot2 = nums1[newIndex1], nums2[newIndex2]
                if pivot1 <= pivot2:
                    k -= newIndex1 - index1 + 1  # 更新k值
                    index1 = newIndex1 + 1  # 更新下标值
                else:
                    k -= newIndex2 - index2 + 1  # 更新k值
                    index2 = newIndex2 + 1  # 更新下班值

  
        m, n = len(nums1), len(nums2)
        totalLength = m + n
        if totalLength % 2 == 1:
            return getKthElement((totalLength + 1) // 2)
        else:
            return (getKthElement(totalLength // 2) + getKthElement(totalLength // 2 + 1)) / 2
```

Rust:
```rust
pub fn get_kth_element(nums1: &Vec<i32>, nums2: &Vec<i32>, k: usize) -> i32 {
        let (mut index1, mut index2) = (0, 0);
        let mut k = k;
    loop {
        // 特殊情况
        if index1 == nums1.len() {
            return nums2[index2 + k - 1];
        }
        if index2 == nums2.len() {
            return nums1[index1 + k - 1];
        }
        if k == 1 {
            return nums1[index1].min(nums2[index2]);
        }
        // 正常情况
        let new_index1 = (index1 + k / 2 - 1).min(nums1.len() - 1);
        let new_index2 = (index2 + k / 2 - 1).min(nums2.len() - 1);
        let pivot1 = nums1[new_index1];
        let pivot2 = nums2[new_index2];
        if pivot1 <= pivot2 {
            k -= new_index1 - index1 + 1; // 更新k值
            index1 = new_index1 + 1; // 更新下标值
        } else {
            k -= new_index2 - index2 + 1; // 更新k值
            index2 = new_index2 + 1; // 更新下标值
        }
    }
}

impl Solution {
    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {
        let m = nums1.len();
        let n = nums2.len();
        let total_length = m + n;

        if total_length % 2 == 1 {
            get_kth_element(&nums1, &nums2, (total_length + 1) / 2) as f64
        } else {
            (get_kth_element(&nums1, &nums2, total_length / 2) + get_kth_element(&nums1, &nums2, total_length / 2 + 1)) as f64 / 2.0
        }
    }
}
```

## 5. 最长回文字符串

```
双指针、字符串、动态规划
```

题解：
![image](https://github.com/user-attachments/assets/afd64dc2-f353-4983-93fb-3483770c01f7)

Python
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n < 2:
            return s
        
        max_len = 1;
        begin = 0;
        dp = [[False] * n for _ in range(n)]  # dp[i][j] 表示 s[i..j] 是否是回文串
        for i in range(n):
            dp[i][i] = True

        # 递推开始
        # 先枚举子串长度
        for L in range(2, n + 1):
            # 枚举左边界，左边界的上限设置可以宽松一些
            for i in range(n):
                # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                j = L + i - 1
                if j >= n:
                    break

                if s[i] != s[j]:
                    dp[i][j] = False
                else:
                    if j - i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j - 1]
                
                if dp[i][j] and j - i + 1 > max_len:
                    max_len = j - i + 1
                    begin = i
        
        return s[begin:begin + max_len]
```

Rust:
```rust
impl Solution {
    pub fn longest_palindrome(s: String) -> String {
        let (mut start, mut end) = (0, 0);
        let s = s.chars().collect::<Vec<_>>();
        let mut dp = vec![vec![false; s.len()]; s.len()];
        for i in (0..s.len()).rev() {
            for j in i..s.len() {
                if i == j || j - i == 1 && s[i] == s[j] {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i + 1][j - 1] && s[i] == s[j];
                }
                
                if dp[i][j] && j - i > end - start {
                    start = i;
                    end = j;
                }
            }
        }
        s[start..=end].iter().collect()
    }
}
```

## 6. z字形变换

```
字符串
```

Python:
```Python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows < 2: return s
        res = ["" for _ in range(numRows)]
        i, flag = 0, -1
        for c in s:
            res[i] += c
            # 到转折点取反
            if i == 0 or i == numRows - 1:
                flag = -flag
            i += flag  # 遍历行索引
        return "".join(res)
```

Rust:
```Rust
impl Solution {
    pub fn convert(s: String, num_rows: i32) -> String {
        if (num_rows < 2) {
            return s;
        }
        let mut res = vec![String::new(); num_rows as usize];
        let mut i = 0;
        let mut flag = -1;

        for c in s.chars() {
            res[i as usize].push(c);
            if i == 0 || i == num_rows - 1 {
                flag = -flag;
            }
            i += flag;
        }
    
        res.concat()
    }
}
```

## 7. 整数取反

```
数学
```

Python:
```Python
class Solution:
    def reverse(self, x: int) -> int:
        INT_MIN, INT_MAX = -2**31, 2**31 - 1
        
        rev = 0
        while x!= 0:
            # INT_MIN 也是一个负数， 不能写成 rev < INT_MIN // 10
            if rev < INT_MIN // 10 + 1 or rev > INT_MAX // 10:
                return 0
            
            digit = x % 10

            # Python3 的取模运算在 x 为负数时也会返回 [0, 9) 以内的结果，因此这里需要进行特殊判断
            if x < 0 and digit > 0:
                digit -= 10
            
            # 同理，Python3 的整数除法在 x 为负数时会向下（更小的负数）取整，因此不能写成 x //= 10
            x = (x - digit) // 10
            rev = rev * 10 + digit
        
        return rev
```

Rust:
```Rust
impl Solution {
    pub fn reverse(x: i32) -> i32 {
        let mut x = x;
        let mut reversed = 0;

        while x != 0 {
            let last_digit = x % 10;
            x /= 10;

            // 检查溢出
            if reversed > i32::MAX / 10 || (reversed == i32::MAX / 10 && last_digit > 7) {
                return 0;
            }
            if reversed < i32::MIN / 10 || (reversed == i32::MIN / 10 && last_digit < -8) {
                return 0;
            }

            reversed = reversed * 10 + last_digit;
        }

        reversed
    }
}
```

## 8. 字符串转换整数

```
字符串
```

Python:
```Python
        s = s.strip()                      # 删除首尾空格
        if not s: return 0                   # 字符串为空则直接返回
        res, i, sign = 0, 1, 1
        int_max, int_min, bndry = 2 ** 31 - 1, -2 ** 31, 2 ** 31 // 10
        if s[0] == '-': sign = -1            # 保存负号
        elif s[0] != '+': i = 0              # 若无符号位，则需从 i = 0 开始数字拼接
        for c in s[i:]:
            if not '0' <= c <= '9' : break     # 遇到非数字的字符则跳出
            if res > bndry or res == bndry and c > '7': return int_max if sign == 1 else int_min # 数字越界处理
            res = 10 * res + ord(c) - ord('0') # 数字拼接
        return sign * res
```

Rust:
```Rust
impl Solution {
    pub fn my_atoi(s: String) -> i32 {
    let mut s = s.trim(); // 删除首尾空格
    if s.is_empty() {
        return 0; // 字符串为空则直接返回
    }

    let mut res = 0;
    let mut i = 1;
    let mut sign = 1;
    let int_max = i32::MAX;
    let int_min = i32::MIN;
    let bndry = (i32::MAX / 10) as i32;

    if s.chars().nth(0) == Some('-') {
        sign = -1; // 保存负号
    } else if s.chars().nth(0) != Some('+') {
        i = 0; // 若无符号位，则需从 i = 0 开始数字拼接
    }

    for c in s.chars().skip(i) {
        if !c.is_digit(10) {
            break; // 遇到非数字的字符则跳出
        }
        if res > bndry || (res == bndry && c.to_digit(10).unwrap() > 7) {
            return if sign == 1 { int_max } else { int_min }; // 数字越界处理
        }
        res = res * 10 + c.to_digit(10).unwrap() as i32; // 数字拼接
    }

    sign * res
    }
}
```

## 9. 回文数

```
数学
```

Python:
```Python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # x = str(x)
        # if x[:] == x[::-1]:
        #     return True
        # else:
        #     return False

        # 反转一半的数字
        if x < 0 or (x % 10 == 0 and x != 0):
            return False

        reve = 0
        while x > reve:
            reve = reve * 10 + x % 10
            x = x // 10

        print(x)
        print(reve)

        return True if x == reve or x == reve // 10 else False
```

```Rust
impl Solution {
    pub fn is_palindrome(x: i32) -> bool {
        let mut x = x;
        if x < 0 || (x % 10 == 0 && x != 0) {
            return false
        }

        let mut reve = 0;
        while x > reve {
            reve = reve * 10 + x % 10;
            x = x / 10;
        }

        if x == reve || x == reve / 10 {
            return true
        } else {
            return false
        }
    }
}
```

## 10. 正则表达式匹配

```
递归、字符串、动态规划
```

Python:
```Python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)

        def matches(i: int, j: int) -> bool:
            if i == 0:
                return False
            if p[j - 1] == '.':
                return True
            
            return s[i-1] == p[j-1]
        
        f = [[False] * (n + 1) for _ in range(m + 1)]

        f[0][0] = True
        
        for i in range(m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    f[i][j] |= f[i][j-2]
                    if matches(i, j - 1):
                        f[i][j] |= f[i-1][j]
                else:
                    if matches(i, j):
                        f[i][j] |= f[i-1][j-1]
        return f[m][n]
```

Rust:
```Rust
impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        let m = s.len();
        let n = p.len();
        let mut f = vec![vec![false; n + 1]; m + 1];
    
        f[0][0] = true;
    
        for i in 0..=m {
            for j in 1..=n {
                if p.chars().nth(j - 1) == Some('*') {
                    f[i][j] |= f[i][j - 2];
                    if matches(&s, &p, i, j - 1) {
                        f[i][j] |= f[i - 1][j];
                    }
                } else {
                    if matches(&s, &p, i, j) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        f[m][n]
    }
}

pub fn matches(s: &str, p: &str, i: usize, j: usize) -> bool {
    if i == 0 {
        return false;
    }
    if p.chars().nth(j - 1) == Some('.') {
        return true;
    }
    s.chars().nth(i-1) == p.chars().nth(j-1)
}
```

## 11. 盛最多水的容器

```
贪心、数组、双指针
```

Python:
```Python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 双指针指，移动短板
        left = 0
        right = len(height) - 1
        s = 0

        while left < right:
            min_height = min(height[left], height[right])  # 寻找短板
            
            if s < min_height * (right - left):
                s = min_height * (right - left)
            
            # 移动短板, 寻找较高的木板
            if height[left] > height[right]:
                right -= 1
            else:
                left += 1
        
        return s
```

Rust:
```Rust
impl Solution {
    pub fn max_area(height: Vec<i32>) -> i32 {
        // 双指指针, 移动短板
        let mut left = 0;
        let mut right = height.len() as i32 - 1;
        let mut s = 0;

        while left < right {
            // 寻找短板
            let mut min_height = height[left as usize].min(height[right as usize]);

            if s < min_height * (right - left) {
                s = min_height * (right - left);
            }

            // 移动短板，寻找较高的木板
            if height[left as usize] > height[right as usize] {
                right -= 1;
            } else {
                left += 1;
            }
        }

        s
    }
}
```

## 12. 整数转换罗马数字

```
哈希表、数学、字符串
```

Python:
```Python
class Solution:
    def intToRoman(self, num: int) -> str:
        """
        整数转换罗马数字
        :param num: 整数
        :return: 罗马数字字符串
        """
        res = ''

        hashmap = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}

        for key in hashmap:
            if num // key != 0:
                count = num // key
                res += hashmap[key] * count
                num %= key
        
        return res
```

Rust:
```Rust
impl Solution {
    pub fn int_to_roman(num: i32) -> String {
        let mut num = num;
        let mut res = String::new();
        let hashmap = [
            (1000, "M"), (900, "CM"), (500, "D"), (400, "CD"),
            (100, "C"), (90, "XC"), (50, "L"), (40, "XL"),
            (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")
        ];

        for &(key, value) in &hashmap{
            if num / key != 0 {
                let count = num / key;
                res.push_str(&value.repeat(count as usize));
                num %= key;
            }
        }

        res
    }
}
```

## 13. 罗马数字转整数

```
哈希表、数学、字符串
```

Python:
```Python
class Solution:
    def romanToInt(self, s: str) -> int:
        """
        罗马数字转整数
        :param s:
        :return:
        """
        d = {'I': 1, 'IV': 3, 'V': 5, 'IX': 8, 'X': 10, 'XL': 30, 'L': 50, 'XC': 80, 'C': 100, 'CD': 300,
                       'D': 500, 'CM': 800, 'M': 1000}
        # res = 0

        # for i, n in enumerate(s):
        #     # s[max(i - 1, 0):i + 1] -> 前一个字符与当前字符组成的字符串
        #     # n -> 当前字符
        #     num = hashmap.get(s[max(i - 1, 0):i + 1], hashmap[n])
        #     res += num
        # return res

        # 简约版
        return sum(d.get(s[max(i-1,0):i+1], d[n]) for i, n in enumerate(s))
```

Rust:
```Rust
use std::collections::HashMap;
impl Solution {
    pub fn roman_to_int(s: String) -> i32 {
        let mut hashmap = HashMap::new();
        hashmap.insert("I", 1);
        hashmap.insert("IV", 3);
        hashmap.insert("V", 5);
        hashmap.insert("IX", 8);
        hashmap.insert("X", 10);
        hashmap.insert("XL", 30);
        hashmap.insert("L", 50);
        hashmap.insert("XC", 80);
        hashmap.insert("C", 100);
        hashmap.insert("CD", 300);
        hashmap.insert("D", 500);
        hashmap.insert("CM", 800);
        hashmap.insert("M", 1000);

        let mut res = 0;
        let chars: Vec<char> = s.chars().collect();

        for i in 0..s.len() {
            let num = if i > 0 && hashmap.contains_key(&s[i - 1..=i]) {
                hashmap[&s[i - 1..=i]]
            } else {
                hashmap[&chars[i].to_string()]
            };
            res += num;
        }

        res
    }
}
```

## 14. 最长公共前缀

```
字典树、字符串
```

Python:
```Python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        # 横向扫描法
        # if not strs:
        #     return ""

        # prefix, length = strs[0], len(strs[0])
        # for i in range(1, len(strs)):
        #     prefix = self.lcp(prefix, strs[i])
        #     if not prefix:
        #         break

        # return prefix

        # 纵向扫描
        # if not strs:
        #     return ""
        
        # length, count = len(strs[0]), len(strs)

        # for i in range(length):
        #     c = strs[0][i]
        #     if any(i == len(strs[j]) or c != strs[j][i] for j in range(1, count)):
        #         return strs[0][:i]
        
        # return strs[0]

        # 分治法
        def lcp(start, end):
            if start == end:
                return strs[start]
            
            mid = (start + end) // 2
            lcpLeft, lcpRight = lcp(start, mid), lcp(mid + 1, end)  # 左边最长公共前缀、右边最长公共前缀
            minLength = min(len(lcpLeft), len(lcpRight))
            for i in range(minLength):
                if lcpLeft[i] != lcpRight[i]:
                    return lcpLeft[:i]
            
            return lcpLeft[:minLength]
        
        return "" if not strs else lcp(0, len(strs) - 1)

    # def lcp(self, str1, str2):
    #     length, index = min(len(str1), len(str2)), 0
    #     while index < length and str1[index] == str2[index]:
    #         index += 1
    #     return str1[:index]
```

Rust:
```Rust
impl Solution {
    pub fn longest_common_prefix(strs: Vec<String>) -> String {
        // 横向扫描
        // if strs.is_empty() {
        //     return String::new()
        // }
        // let mut prefix = &strs[0][..];
        // for str in &strs[1..] {
        //     prefix = Solution::lcp(prefix, str);
        //     if prefix.is_empty() {
        //         break
        //     }
        // }
        // prefix.to_string()

        // 纵向扫描
        // if strs.len() == 0 || strs.is_empty() {
        //     return String::new();
        // }
        // let lenght = strs[0].len();
        // let count = strs.len();
        // for i in 0..lenght {
        //     let c = strs[0].chars().nth(i);
        //     for j in 1..count {
        //         if i == strs[j].len() || c != strs[j].chars().nth(i) {
        //             return strs[0][..i].to_string();
        //         }
        //     }
        // }
        // strs[0][..].to_string()

        // 分治法 (报错: thread 'main' has overflowed its stack (solution.rs))
        fn lcp(strs: &Vec<String>, start: usize, end: usize) -> String {
            if start == end {
                return strs[start][..].to_string();
            }
    
            let mid = (start + end) / 2;
            let lcpLeft = lcp(strs, start, mid);  // 左部分最长公共前缀
            let lcpRight = lcp(strs, start, mid + 1);  // 右部分最长公共前缀
            let minLength = lcpLeft.len().min(lcpRight.len());
    
            for i in 0..minLength {
                if lcpLeft.chars().nth(i) != lcpRight.chars().nth(i) {
                    return lcpLeft[..i].to_string();
                }
            }
    
            return lcpLeft[..minLength].to_string();
        }


        if strs.is_empty() {
            return String::new();
        } else {
            lcp(&strs, 0, strs.len() - 1)[..].to_string()
        }
    }

    // pub fn lcp<'a>(str1: &'a str, str2: &'a str) -> &'a str {
    //     let lenght = str1.len().min(str2.len());
    //     let mut index = 0;
    //     while index < lenght && str1.chars().nth(index) == str2.chars().nth(index) {
    //         index += 1;
    //     }
    //     &str1[..index]
    // }

}
```

## 15. 三数之和

```
数组、双指针、排序
```

解题思路:

![image](./graph/Snipaste_2024-10-17_10-38-59.png)

Python:
```Pyhton
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        """
        排序 + 双指针
        """
        num.sort()
        res, k = [], 0
        for k in range(len(nums) - 2):
            if nums[k] > 0: break  # 当nums[k]元素 > 0, 说明已经没有 三数之和=0            
            if k > 0 and num[k] == num [k-1]: continue  # 跳过已经遍历过的元素
            i, j = k + 1, len(nums) - 1

            while i < j:
                s = nums[k] + nums[i] + nums[j]
                if s < 0:
                    i += 1
                    while i < j and nums[i] = nums[i - 1]: i += 1
                elif s > 0:
                    j -= 1
                    while i < j and num[j] == nums[j + 1]: j -= 1
                else:
                    res.append([nums[k], nums[i], nums[j]])
                    i += 1
                    j -= 1
                    while i < j and nums[i] = nums[i - 1]: i += 1
                    while i < j and num[j] == nums[j + 1]: j -= 1
        return res
```

Rust:
```Rust
use std::collections::HashSet;

impl Solution {
    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut nums = nums;
        nums.sort();
        let mut res = HashSet::new();
        let mut k = 0;
        for k in 0..nums.len()-2 {
            if nums[k] > 0 { break; }
            if k > 0 && nums[k] == nums[k-1] { continue; }
            let mut i = k + 1;
            let mut j = nums.len() - 1;
            while i < j {
                let mut s = nums[k] + nums[i] + nums[j];
                if s < 0 {
                    i += 1;
                    while i < j && nums[i] == nums[i-1] { i += 1; }
                } else if s > 0 {
                    j -= 1;
                    while i < j && nums[j] == nums[j+1] { j -= 1; }
                } else {
                    res.insert(vec![nums[k], nums[i], nums[j]]);
                    i += 1;
                    j -= 1;
                    while i < j && nums[i] == nums[i-1] { i += 1; }
                    while i < j && nums[j] == nums[j+1] { j -= 1; }
                }
            }
        }

        res.into_iter().collect()
    }
}
```

## 16. 最接近的三数之和

```
数组、双指针、排序
```

![image](https://github.com/user-attachments/assets/2b7fb8f9-61cb-4d22-9073-64de276bd83b)


Python
```Python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums_len = len(nums)
        nums.sort()
        res = (nums[nums_len - 1] + nums[nums_len - 2] + nums[nums_len - 3])
        for k in range(len(nums) - 2):
            start, end = k + 1, len(nums) - 1
            while start < end:
                cur = nums[k] + nums[start] + nums[end]
                if cur < target:
                    start += 1
                    while start < end and nums[start] == nums[start - 1]: start += 1
                elif cur > target:
                    end -= 1
                    while start < end and nums[end] == nums[end + 1]: end -= 1
                elif cur == target:
                    return cur

                res = res if abs(target - cur) > abs(target - res) else cur

        return res
```

Rust:
```Rust
impl Solution {
    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {
        /*
        最接近的三数之和
         */
        let mut nums = nums;
        nums.sort();
        let nums_len = nums.len();
        let mut res = nums[nums_len - 1] + nums[nums_len - 2] + nums[nums_len - 3];
        for k in 0..nums_len - 2 {
            let mut i = k + 1;
            let mut j = nums_len - 1;
            while i < j {
                let cur = nums[k] + nums[i] + nums[j];
                if cur < target {
                    i += 1;
                    while i < j && nums[i] == nums[i - 1] { i += 1;}
                } else if cur > target {
                    j -= 1;
                    while i < j && nums[j] == nums[j + 1] {j -= 1;}
                } else if cur == target {
                    return cur
                }
                if (target - cur).abs() < (target - res).abs() { res = cur; }
            }
        }
        return res     
    }
}
```

## 17. 电话号码的字母组合

```
哈希表、字符串、回溯
```

![image](https://github.com/user-attachments/assets/e3753f21-8a11-4ca1-9606-53ec154bfcbd)

![image](https://github.com/user-attachments/assets/47dbd05f-080c-4d94-9d77-f2901b224454)

Python:
```Python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return list()

        # 定义一个号码与字母的映射
        num_to_chs = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }
    
        def backrack(index):
            if index == len(digits):
                res.append(''.join(com))
            else:
                num = digits[index]
                chs = num_to_chs[num]
                for ch in chs:
                    com.append(ch)
                    backrack(index + 1)  # 递归
                    com.pop()  # 回溯
        
        com = list()
        res = list()
        backrack(0)

        return res
```

Rust:
```Rust
use std::collections::HashMap;
use std::slice::Iter;
impl Solution {
    pub fn letter_combinations(digits: String) -> Vec<String> {
        if digits.is_empty() {
            return vec![];
        }

        // 定义一个号码与字母的映射
        let num_to_chs: HashMap<char, &'static str> = [
            ('2', "abc"),
            ('3', "def"),
            ('4', "ghi"),
            ('5', "jkl"),
            ('6', "mno"),
            ('7', "pqrs"),
            ('8', "tuv"),
            ('9', "wxyz"),
        ].iter().cloned().collect();

        let mut res = Vec::new();
        let mut com = String::new();
        Solution::backtrack(&digits, 0, &num_to_chs, &mut com, &mut res);
        res
    }

    fn backtrack(
        digits: &str,
        index: usize,
        num_to_chs: &HashMap<char, &'static str>,
        com: &mut String,
        res: &mut Vec<String>,
    ) {
        if index == digits.len() {
            res.push(com.clone());
        } else {
            let num = digits.chars().nth(index).unwrap();
            if let Some(chs) = num_to_chs.get(&num) {
                for ch in chs.chars() {
                    com.push(ch);
                    Solution::backtrack(digits, index + 1, num_to_chs, com, res);  // 递归
                    com.pop();  // 回溯
                }
            }
        }
    }
}
```

## 18 四数之和

```
数组、双指针、排序
```

![image](https://github.com/user-attachments/assets/cf906c10-702a-4c72-a58e-6e898d30c43e)

![image](https://github.com/user-attachments/assets/07026777-cda6-46a9-a7c3-454c4509e567)

Pyhton:
```Python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        """
        四数之和
        :param nums:
        :param target:
        :return:
        """
        nums.sort()
        ans = []
        n = len(nums)
        for a in range(n - 3):  # 枚举第二个数
            x = nums[a]
            if a and x == nums[a - 1]:  # 跳过重复数据
                continue
            if x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target:  # 优化一
                continue
            if x + nums[-1] + nums[-2] + nums[-3] < target:  # 优化二
                continue

            for b in range(a + 1, n - 2):  # 枚举第二个数
                y = nums[b]
                if b > a + 1 and y == nums[b - 1]:  # 跳过重复数字
                    continue
                if x + y + nums[b + 1] + nums[b + 2] > target:  # 优化三
                    continue
                if x + y + nums[-1] + nums[-2] < target:  # 优化四
                    continue

                # 双指针枚举第三个数和第四个数
                c = b + 1
                d = n - 1
                while c < d:
                    s = x + y + nums[c] + nums[d]  # 四数之和
                    if s > target:
                        d -= 1
                    elif s < target:
                        c += 1
                    else:
                        ans.append([x, y, nums[c], nums[d]])
                        c += 1
                        while c < d and nums[c] == nums[c - 1]:
                            c += 1
                        d -= 1
                        while c < d and nums[d] == nums[d + 1]:
                            d -= 1
        return ans
```

Rust:
```Rust
use std::collections::HashSet;

impl Solution {
    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        if nums.len() < 4 {
            return vec![];
        }
        let target = target as i64;
        let mut nums = nums;
        nums.sort();
        let mut ans = HashSet::new();
        let n = nums.len();

        for a in 0..n - 3 {
            let x = nums[a];
            if a > 0 && x == nums[a - 1] {
                continue;
            }
            let temp1 = (x as i64 + nums[a+1] as i64 + nums[a+2] as i64 + nums[a+3] as i64);
            if temp1 > target {
                continue;
            }
            let temp2 = (x as i64 + nums[n - 1] as i64 + nums[n - 2] as i64 + nums[n - 3] as i64 );
            if temp2 < target {
                continue;
            }
            for b in a + 1..n - 2 {
                let y = nums[b];
                if b > a + 1 && y == nums[b - 1] {
                    continue;
                }
                let temp3 = (x as i64 + y as i64 + nums[b + 1] as i64 + nums[b + 2] as i64 );
                if temp3 > target {
                    continue;
                }
                let temp4 = (x as i64 + y as i64 + nums[n - 1] as i64 + nums[n - 2] as i64 );
                if temp4 < target {
                    continue;
                }

                let mut c = b + 1;
                let mut d = n - 1;
                while c < d {
                    let s = (x as i64 + y as i64 + nums[c] as i64 + nums[d] as i64);
                    if s > target {
                        d -= 1;
                    } else if s < target {
                        c += 1;
                    } else {
                        ans.insert(vec![x, y, nums[c], nums[d]]);
                        c += 1;
                        while c < d && nums[c] == nums[c - 1] {
                            c += 1;
                        }
                        d -= 1;
                        while c < d && nums[d] == nums[d + 1] {
                            d -= 1;
                        }
                    }
                }
            }
        }

        ans.into_iter().collect()
    }
}
```

## 19 删除链表的倒数第n个节点

```
链表、双指针
```

![image](https://github.com/user-attachments/assets/188e0872-e024-425f-a1dd-686308b1a84c)

Python:
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        """
        删除链表的倒数第n个节点
        思路：利用双指针, end指标前走n结点，然后start 和 end 共同往前走
        :param head:
        :param n:
        :return:
        """
        dummy = ListNode(0, head)
        start = dummy
        end = head

        for i in range(n):
            end = end.next
        
        while end:
            start = start.next
            end = end.next
        
        start.next = start.next.next
        return dummy.next
```

Rust:
```Rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {
        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));
        let mut slow_p = &mut dummy;
        let mut fast_p = &slow_p.clone();

        for _ in 0..=n {
            if let Some(fast_node) = fast_p {
                fast_p = &fast_node.next;
            } else {
                return None;
            }
        }

        while fast_p.is_some() {
            fast_p = &fast_p.as_ref().unwrap().next;
            slow_p = &mut slow_p.as_mut().unwrap().next;
        }

        let remove_p = &mut slow_p.as_mut().unwrap().next;
        slow_p.as_mut().unwrap().next = remove_p.as_mut().unwrap().next.take();

        dummy.unwrap().next
    }
}
```
## 20 有效的括号

```
栈、字符串
```

![image](https://github.com/user-attachments/assets/d5d354d3-0dec-49f6-ba09-aa31584dce52)

Python:
```Python
class Solution:
    def isValid(self, s: str) -> bool:
        """
        使用栈的特性，进行解题
        遇到左括号进栈，遇到有括号(且是同一类型的括号)出栈
        :param s:
        :return:
        """
        if len(s) % 2 != 0:
            return False

        pairs = {
            ")": "(",
            "]": "[",
            "}": "{",
        }

        stack = list()
        for ch in s:
            if ch in pairs:
                if not stack or stack[-1] != pairs[ch]:
                    return False
                stack.pop()
            else:
                stack.append(ch)

        return not stack
```

Rust:
```Rust
use std::collections::HashMap;
impl Solution {
    pub fn is_valid(s: String) -> bool {
        if s.len() % 2 != 0 {
            return false;
        }

        let pairs = HashMap::from([
            (')', '('),
            (']', '['),
            ('}', '{'),
        ]);

        let mut stack = Vec::new();
        for ch in s.chars() {
            if let Some(&closing) = pairs.get(&ch) {
                if stack.is_empty() || stack.pop().unwrap() != closing {
                    return false
                }
            } else {
                stack.push(ch)
            }
        }

        stack.is_empty()
    }
}
```

## 21 两个有序链表合并

```
递归、链表
```

Python:
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        head = ListNode()
        temp = head

        while list1 and list2:
            if list1.val <= list2.val:
                temp.next = list1
                temp = temp.next
                list1 = list1.next
            elif list1.val > list2.val:
                temp.next = list2
                temp = temp.next
                list2 = list2.next

        while list1:
            temp.next = list1
            temp = temp.next
            list1 = list1.next

        while list2:
            temp.next = list2
            temp = temp.next
            list2 = list2.next
        
        return head.next
```


Rust:
```Rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut dummy_head = Some(Box::new(ListNode::new(0)));
        let mut temp = &mut dummy_head;

        let mut l1 = list1;
        let mut l2 = list2;

        while l1.is_some() && l2.is_some() {
            let l1_val = l1.as_ref().unwrap().val;
            let l2_val = l2.as_ref().unwrap().val;

            if l1_val <= l2_val {
                temp.as_mut().unwrap().next = l1.take();
                l1 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            } else {
                temp.as_mut().unwrap().next = l2.take();
                l2 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            }

            temp = &mut temp.as_mut().unwrap().next;
        }

        if l1.is_some() {
            temp.as_mut().unwrap().next = l1;
        } else {
            temp.as_mut().unwrap().next = l2;
        }

        dummy_head.unwrap().next
    }
}
```

## 22 括号生成

```
字符串、动态规划、回溯
```

![image](https://github.com/user-attachments/assets/c561a458-d7aa-449f-ae7e-03a556589660)


Python
```Python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        """
        递归
        枚举填左括号还是右括号
        :param n:
        :return:
        """
        m = n * 2  # 括号长度
        ans = []
        path = [''] * m  # 所有括号长度都是一样的m

        # i = 目前填写了多少括号
        # open = 左括号个数，i - open = 右括号个数
        def dfs(i, open):
            if i == m:  # 括号构造完成
                ans.append(''.join(path))
                return
            if open < n:  # 可以填写左括号
                path[i] = '('  # 覆盖
                dfs(i + 1, open + 1)
            if i - open < open:
                path[i] = ')'  # 覆盖
                dfs(i + 1, open)

        dfs(0, 0)
        return ans
```

Rust:
```Rust
impl Solution {
    fn back_trace(s: String, n: usize, right: usize, left: usize, result: &mut Vec<String>) {
		if s.len() == 2 * n {
			result.push(s);
			return;
		}

		if left < n {
			let mut s = s.to_owned();
			s.push('(');
			Self::back_trace(s, n, right, left + 1, result);
		}

		if left > 0 && left > right && right < n {
			let mut s = s.to_owned();
			s.push(')');
			Self::back_trace(s, n, right + 1, left, result);
		}
	}

	pub fn generate_parenthesis(n: i32) -> Vec<String> {
		let mut result = vec![];
		Self::back_trace(String::new(), n as usize, 0, 0, &mut result);
		result
	}
}
```

## 23 合并k个有序链表

```
链表、分治、堆(优先队列)、归并排序
```

Python:
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def Merge(slef, list1, list2):
        if not list1 and not list2:
            return

        if not list1:
            return list2
        if not list2:
            return list1

        head = ListNode()
        temp = head

        while list1 and list2:
            if list1.val <= list2.val:
                temp.next = list1
                temp = temp.next
                list1 = list1.next
            elif list1.val > list2.val:
                temp.next = list2
                temp = temp.next
                list2 = list2.next

        while list1:
            temp.next = list1
            temp = temp.next
            list1 = list1.next

        while list2:
            temp.next = list2
            temp = temp.next
            list2 = list2.next
        
        return head.next

    def driverMerge(self, lists, left, right):
        if left > right:
            return None
        elif left == right:
            return lists[left]
        mid = (left + right) // 2
        left_link = self.driverMerge(lists, left, mid)
        right_link = self.driverMerge(lists, mid + 1, right)
        return self.Merge(left_link, right_link)
        
        

    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        """
        二分
        归并
        """
        return self.driverMerge(lists, 0, len(lists)-1)
```

Rust:
```Rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    fn merge(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) ->  Option<Box<ListNode>> {
        let mut dummy_head = Some(Box::new(ListNode::new(0)));
        let mut temp = &mut dummy_head;

        let mut l1 = list1;
        let mut l2 = list2;

        while l1.is_some() && l2.is_some() {
            let l1_val = l1.as_ref().unwrap().val;
            let l2_val = l2.as_ref().unwrap().val;

            if l1_val <= l2_val {
                temp.as_mut().unwrap().next = l1.take();
                l1 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            } else {
                temp.as_mut().unwrap().next = l2.take();
                l2 = temp.as_mut().unwrap().next.as_mut().unwrap().next.take();
            }

            temp = &mut temp.as_mut().unwrap().next;
        }

        if l1.is_some() {
            temp.as_mut().unwrap().next = l1;
        } else {
            temp.as_mut().unwrap().next = l2;
        }

        dummy_head.unwrap().next
    }

    fn derive_merge(lists: &[Option<Box<ListNode>>], left: usize, right: usize) -> Option<Box<ListNode>> {
        if left > right {
            return None;
        } else if left == right {
            return lists[left].clone();
        }
        let mid = (left + right) / 2;
        let left_link = Solution::derive_merge(lists, left, mid);
        let right_link = Solution::derive_merge(lists, mid + 1, right);
        Solution::merge(left_link, right_link)
    }

    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {
        if lists.is_empty() {
            return None;
        }
        Solution::derive_merge(&lists, 0, lists.len() - 1)
    }
}
```

## 24 两两交换链表中的节点

```
递归、链表
```

Python:
```Python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        循环
        """
        dummy = ListNode(next=head)  # 用哨兵节点简化代码逻辑
        node0 = dummy
        node1 = head
        while node1 and node1.next:  # 至少有两个节点
            node2 = node1.next
            node3 = node2.next

            node0.next = node2  # 0 -> 2
            node2.next = node1  # 2 -> 1
            node1.next = node3  # 1 -> 3

            node0 = node1  # 下一轮交换，0 是 1
            node1 = node3  # 下一轮交换，1 是 3
        return dummy.next  # 返回新链表的头节点

    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        递归
        """
        if head is None or head.next is None:
            return head  # 不足两个节点，无需交换
        
        node1 = head
        node2 = head.next
        node3 = node2.next

        node1.next = self.swapPairs(node3)  # 指向递归返回的链表头
        node2.next = node1  # node2 指向 node1

        return node2  # 返回交换后的链表头节点
```

Rust:
```Rust
```

## 25 反转链表

```
递归、链表
```

方法一：迭代（双指针）
![image](https://github.com/user-attachments/assets/798047c2-a745-43bc-a94b-0bd23a01b750)

方法二：递归
![image](https://github.com/user-attachments/assets/3e1e8fb6-27f4-49f7-a436-dbec008eeacd)

![image](https://github.com/user-attachments/assets/d95d1e5a-ffaa-42c9-bffb-b443e06a5e99)

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # # 迭代(双指针法) 
        # cur, pre = head, None
        # while cur:
        #     temp = cur.next  # 暂存后继节点 cur.next
        #     cur.next = pre  # 修改 next 引用指向
        #     pre = cur  # pre 暂存 cur
        #     cur = temp  # cur 访问下一节点
        
        # return pre

        # 递归方法
        def recur(cur, pre):
            if not cur: return pre  # 终止条件
            res = recur(cur.next, cur)  # 递归后继节点
            cur.next = pre  # 修改节点引用指向
            return res  # 返回反转链表的头节点
        
        return recur(head, None)  # 调用递归并返回
```

## 25 反转链表Ⅱ

```
递归、链表
```

Python:
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        dummy = ListNode(next=head)
        p0 = dummy
        for _ in range(left - 1):
            p0 = p0.next


        pre = None
        cur = p0.next
        for _ in range(right - left+1):
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        
        p0.next.next = cur
        p0.next = pre

        return dummy.next
```

## 25 k个一组反转链表

```
递归、链表
```

![image](https://github.com/user-attachments/assets/cb930b7c-6dc9-4c01-b6de-02a79e5f2872)

![image](https://github.com/user-attachments/assets/ab06f0df-cd19-4ed9-98c6-d574c6b69e7e)

Python:
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        n = 0
        cur = head
        # 循环，计算链表的长度
        while cur:
            n += 1
            cur = cur.next

        # 开始反转数组
        dummy = ListNode(next=head)
        p0 = dummy
        while n >= k:
            # k个节点为一组
            n -= k
            pre = None
            cur = p0.next

            # 反转链表
            for i in range(k):
                print(i)
                temp = cur.next
                cur.next = pre
                pre = cur
                cur = temp
            
            # 连接反转后链表
            temp2 = p0.next
            p0.next.next = cur
            p0.next = pre
            p0 = temp2
        
        return dummy.next
```

## 26 删除有序数组中的重复项

```
数组、双指针
```

题解：
![image](https://github.com/user-attachments/assets/c576813e-6bb5-48f2-b53a-4eeb2f1db476)

![image](https://github.com/user-attachments/assets/67f1017a-0c0b-4397-b3df-2376b4bd8e6f)

Python:
```Python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        k = 1
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                nums[k] = nums[i]
                k += 1
        return k
```

Rust:
```Rust
impl Solution {
    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
        let mut k = 1;
        for i in 1..nums.len() {
            if nums[i] != nums[i-1] {
                nums[k] = nums[i];
                k += 1;
            }
        }
        k as i32
    }
}
```

## 27 移除元素

```
数组、双指针
```

题解：
题解与"删除有序数组中的重复项"的题解，差不多，将 nums[i] != nums[i-1] 换成 nums[i] != val

Python:
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[k] = nums[i]
                k += 1
        return k
```

Rust:
```rust
impl Solution {
    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {
        let mut k = 0;
        for i in 0..nums.len() {
            if nums[i] != val {
                nums[k] = nums[i];
                k += 1;
            }
        }
        k as i32
    }
}
```

## 28 找出字符串中第一个匹配项的下标

```
双指子、字符串、字符串匹配
```

![image](https://github.com/user-attachments/assets/bd8c558e-5e69-4ee4-8de6-b681cea179ca)

Python:
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        """
        暴力法
        
        """
        n = len(haystack)
        m = len(needle)
        for i in range(0, m-n+1):
            # 字符串 needle 在 haystack 中的子串空间为 m-n
            if haystack[i:i+m] == needle:
                # haystack[i:i+m]的子串 等于 needle, 说明已经匹配到needle在haystack中
                return i
        return -1
```

Rust
```Rust
impl Solution {
    pub fn str_str(haystack: String, needle: String) -> i32 {
        let n = haystack.len();
        let m = needle.len();
        if m == 0 {
            return 0;
        }
        if m > n {
            return -1;
        }
        for i in 0..n-m+1 {
            if &haystack[i..i+m] == &needle {
                return i as i32;
            }
        }
        -1
    }
}
```

方法二：KMP算法

![image](https://github.com/user-attachments/assets/2a3854eb-0d69-4138-81a3-af566bf69563)

![image](https://github.com/user-attachments/assets/55ac9ab2-5560-4f08-bf25-a99754c78240)

![image](https://github.com/user-attachments/assets/654e4709-30dc-4a2c-9bb7-730b16777c44)

![image](https://github.com/user-attachments/assets/f455f46e-3cd6-4356-8a0d-92451d45b69e)

![image](https://github.com/user-attachments/assets/5b68f7c6-6c37-494d-ba2e-c41280499d2b)

![image](https://github.com/user-attachments/assets/9db02778-8ed7-470e-9234-e160f82f96be)

![image](https://github.com/user-attachments/assets/817c945d-1d05-446e-a1fd-07b57670fa6f)

```java
 for (int right = 1, left = 0; right < needleLength; right++) {
//            定义好两个指针right与left
//            在for循环中初始化指针right为1，left=0,开始计算next数组，right始终在left指针的后面
            while (left > 0 && needle.charAt(left) != needle.charAt(right)) {
//                如果不相等就让left指针回退，到0时就停止回退
                left = next[left - 1];//进行回退操作；
            }
            if (needle.charAt(left) == needle.charAt(right)) {
                left++;
            }
            next[right] = left;
// 这是从 1 开始的

        }
// 循环结束的时候，next数组就已经计算完毕了
```

![image](https://github.com/user-attachments/assets/035c5ce8-07e4-4744-b21c-c3655268d1f3)

![image](https://github.com/user-attachments/assets/a6ed144a-dcd0-4562-b64b-7aedfce7f453)

![image](https://github.com/user-attachments/assets/5ecdbd97-77e9-460c-a80e-8ff401ee8626)

![image](https://github.com/user-attachments/assets/b0a32fe3-9e94-4950-bf1e-bb31fddf3408)

![image](https://github.com/user-attachments/assets/b5c6710d-e39b-4b3b-b9da-1ab1428981b6)

![image](https://github.com/user-attachments/assets/d8960d6d-6385-4e12-a87e-feec2d6908e7)

代码实现
```java
    class Solution {
    public int strStr(String haystack, String needle) {
//自己敲一下子 前缀表不需要减一的实现方式
        int needleLength = needle.length();
        if (needleLength == 0) return 0;
//        当needle是空字符串时，返回0

        int[] next = new int[needleLength];
//        定义好next数组
        for (int right = 1, left = 0; right < needleLength; right++) {
//            定义好两个指针right与left
//            在for循环中初始化指针right为1，left=0,开始计算next数组，right始终在left指针的后面
            while (left > 0 && needle.charAt(left) != needle.charAt(right)) {
//                如果不相等就让left指针回退，到0时就停止回退
                left = next[left - 1];//进行回退操作；
            }
            if (needle.charAt(left) == needle.charAt(right)) {
                left++;
            }
            next[right] = left;
// 这是从 1 开始的

        }
// 循环结束的时候，next数组就已经计算完毕了


        for (int i = 0,j=0; i <haystack.length() ; i++) {

            while (j>0&&haystack.charAt(i)!=needle.charAt(j)){
                j=next[j-1];
            }
            if (haystack.charAt(i)==needle.charAt(j)){
                j++;
            }
            if (j==needleLength) return i-needleLength+1;
        }
        return -1;


    }
}
```

![image](https://github.com/user-attachments/assets/5c605a3b-7c1e-475c-b1b9-20fc4a6c162f)

![image](https://github.com/user-attachments/assets/12b46468-2bd0-4181-80bc-a92afe7245e3)

![image](https://github.com/user-attachments/assets/c90980bb-76f8-42ae-8d96-5c0a05457ddd)

![image](https://github.com/user-attachments/assets/02ecd299-3f1b-47f0-8faf-1a36b3f8c566)

![image](https://github.com/user-attachments/assets/0b9e916c-a553-4c28-8da6-8f842c6a4dbb)


Python:
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        # KMP算法
        def build_next(pattern):
            m = len(pattern)
            next = [-1] * m
            i, j = 0, -1
            while i < m - 1:
                if j == -1 or pattern[i] == pattern[j]:
                    i += 1
                    j += 1
                    next[i] = j
                else:
                    j = next[j]
            return next

        n = len(haystack)
        m = len(needle)
        next = build_next(needle)
        i, j = 0, 0
        while i < n and j < m:
            if j == -1 or haystack[i] == needle[j]:
                i += 1
                j += 1
            else:
                j = next[j]
        if j == m:
            return i - j
        return -1
```

## 29 两数相除

```
位运算、数学
```

题解：指数递增，每次往上加一次本身，由于是指数，也并不会加几次，所以还是很满足要求的

Python:
```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        INT_MIN, INT_MAX = -2 ** 31, 2 ** 31 - 1
    
        # 如果被除数等于0, 结果为0
        if dividend == 0:
            return 0
    
        # 如果被除数和除数相等, 结果为1
        if dividend == divisor:
            return 1
    
        # 如果被除数为最小值时
        if dividend == INT_MIN:
            if divisor == 1:
                return INT_MIN
            if divisor == -1:
                return INT_MAX
    
        # "符号处理"
        # 使用flag, 记录符合, flag==True时为负数, flag=False时为正数
        flag = False
        ans = 0
        if divisor > 0:
            divisor = -divisor
            flag = not flag
        if dividend > 0:
            dividend = -dividend
            flag = not flag
    
        # "计算商"
        while dividend <= divisor:
            x = 1
            result = divisor
            while result > -1e9 and dividend <= result + result:
                # 使用二分查找的思想加速计算过程
                # 内层循环通过不断翻倍x和d来找到最大的x，使得dividend >= result
                x += x
                result += result
            # 当 result < -1e9 或 result + result > dividend 就跳出循环, 
            ans += x
            dividend -= result
    
        return -ans if flag else ans
```

Rust:
```rust
impl Solution {
    pub fn divide(dividend: i32, divisor: i32) -> i32 {
        let mut dividend = dividend;
        let mut divisor = divisor;
        let INT_MAX = i32::MAX;
        let INT_MIN = i32::MIN;

        if dividend == 0 {
            return 0;
        }
        if dividend == divisor {
            return 1
        }

        if dividend == INT_MIN {
            if divisor == -1 {
                return INT_MAX;
            }

            if divisor == 1 {
                return INT_MIN;
            }
        }

        // 使用flag，记录符号，flag=false为正数，flag=true为负数
        let mut flag = false;
        if dividend > 0 {
            dividend = -dividend;
            flag = !flag;
        }
        if divisor >0 {
            divisor = -divisor;
            flag = !flag;
        }


        // 计算商
        let mut ans = 0;
        while dividend <= divisor {
            let mut x = 1;
            let mut result = divisor;
            // 指数递增
            while result > -1e9 as i32 && dividend <= result + result {
                x += x;
                result += result;
            }
            ans += x;
            dividend -= result;
        }
        if flag {
            -ans
        } else {
            ans
        }
    }
}
```

## 30 串联所有单词的子串

```
哈希表、字符串、滑动窗口
```

方法一：朴素哈希表

![image](https://github.com/user-attachments/assets/c83da03e-b77d-4682-9c94-af1a64a88832)

Python:
```Python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        """
        哈希表 + 滑动窗口
        """
        # 定义n:字符串s长度, m:单词个数, w:单词长度
        n = len(s)
        m = len(words)
        w = len(words[0])
        words_map = {}  # word哈希表
        for i in range(m):
            words_map[words[i]] = words_map.get(words[i], 0) + 1
        res = []  # 结果列表, 存储结果开始索引
        left, right = 0, m * w  # 定义窗口边界
        if right > n:
            return []

        # 开始寻找
        for i in range(right, n+1):
            temp_map = {}  # 临时哈希表
            sub_str = s[left:right]  # 滑动窗口子串
            for j in range(m):
                temp_word = sub_str[j * w:j * w + w]
                if temp_word in words_map:
                    temp_map[temp_word] = temp_map.get(temp_word, 0) + 1
                else:
                    # 当前窗口的子串的单词不在words里，跳出
                    break
            if temp_map == words_map:
                res.append(left)
            # 滑动窗口
            left += 1
            right += 1
        return res
```

方法二：哈希表 + 滑动窗口

![image](https://github.com/user-attachments/assets/16673f4d-baaa-4e5c-8f03-77773cde7eaa)

- step1：以 "当前下标" 与 "单词长度" 取余结果，进行循环分类

![滑动窗口分类](https://github.com/user-attachments/assets/c41302ac-8d50-4b63-b85f-bf05c79345da)

- step2: 滑动窗口移动 step_size 为 word_len:

![image](https://github.com/user-attachments/assets/ffe4f9fb-9d92-48c0-b931-37324e68bc60)

![image](https://github.com/user-attachments/assets/17771a6c-66c1-40ef-9409-551d0b054e1b)

![image](https://github.com/user-attachments/assets/697ebf7f-121e-40e9-be43-39a837baa3e6)

- step3: 临时map表 与 单词哈希表 比较是否相等，就可以找到相应的子串了

Python:
```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        """
        哈希表 + 滑动窗口
        """
        n = len(s)
        m = len(words)
        w = len(words[0])
        word_map = {}
        for i in range(m):
            word_map[words[i]] = word_map.get(words[i], 0) + 1
    
        res = []
        for i in range(w):
            # 以单词长度，进行分类
            temp = dict()
            l, r = i, i
            # 每类循环, 初始话滑动窗口
            while r < m * w:
                temp_word = s[r:r + w]
                temp[temp_word] = temp.get(temp_word, 0) + 1
                r += w
            if temp == word_map:
                res.append(l)
    
            # 开始滑动窗口, 步长为"w"单词大小
            while r <= n:
                # 窗口尾部, 增单词
                temp_word = s[r:r + w]
                temp[temp_word] = temp.get(temp_word, 0) + 1
    
                # 窗口头部，减单词
                temp[s[l:l + w]] -= 1  #
                l += w
                r += w
    
                # 重构temp哈希表
                temp = {k: v for k, v in temp.items() if v != 0}
                if temp == word_map:
                    res.append(l)
        return res
```

Rust:
```Rust
use std::collections::HashMap;
impl Solution {
    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {
        let n = s.len();
        let m = words.len();
        let w = words[0].len();
        let mut word_map = HashMap::new();

        if n < m * w {
            return Vec::new();
        }

        for word in words {
            *word_map.entry(word.clone()).or_insert(0) += 1;
        }

        let mut res = Vec::new();
        let mut chars: Vec<char> = s.chars().collect();

        for i in 0..w {
            let mut temp = HashMap::new();
            let mut l = i;
            let mut r = i;

            while r < m * w && r + w <= n {
                let temp_word: String = chars[r..r + w].iter().collect();
                *temp.entry(temp_word.clone()).or_insert(0) += 1;
                r += w;
            }
            if temp == word_map {
                res.push(l as i32);
            }


            while r < n && r + w <= n {
                println!("{}", r);
                // 窗口尾部向后移动
                let temp_word2: String = chars[r..r + w].iter().collect();
                *temp.entry(temp_word2.clone()).or_insert(0) += 1;

                // 窗口头部向后移动
                let temp_word3: String = chars[l..l + w].iter().collect();
                *temp.entry(temp_word3.clone()).or_insert(0) -= 1;

                l += w;
                r += w;
                if temp[&temp_word3] == 0 {
                    temp.remove(&temp_word3);
                }
                
                if temp == word_map {
                    res.push(l as i32);
                }
            }
        }
        res
    }
}
```

## 31 下一个排列

```
数组、双指针
```

题解：
```
第一步，倒序遍历查找到第一个降序的元素。
第二步，第二次倒序遍历找到第一个大于降序元素的元素
第三步，对第一个降序元素之后升序排列
```
注:
```
第一个while循环中如果找不到降序元素，i为0，直接升序排列
```

Python:
```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        """
        step1: 找到相邻元素的，降序元素
        step2: 找到大于降序元素的，元素, 然后两个元素进行互换
        step3：对降序元素下标后面的元素，进行升序排序
        """
        length = len(nums)
        i = length - 1
        # 找到相邻元素的，降序元素
        while i > 0 and nums[i-1] >= nums[i]:
            i -= 1
        
        # 找到大于降序元素的，元素, 然后两个元素进行互换
        if i != 0:
            j = length - 1
            while j >0 and nums[j] <= nums[i-1]:
                j -= 1
            nums[i-1], nums[j] = nums[j], nums[i-1]
        
        # 对降序元素下标后面的元素，进行升序排序
        left, right = i, length - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```

Rust:
```rust
impl Solution {
    pub fn next_permutation(nums: &mut Vec<i32>) {
        // step1: 找到相邻元素的，降序元素
        // step2: 找到大于降序元素的，元素, 然后两个元素进行互换
        // step3：对降序元素下标后面的元素，进行升序排序

        // 找到相邻元素的，降序元素
        let length = nums.len();
        let mut i = length - 1;
        while i > 0 && nums[i - 1] >= nums[i] {
            i -= 1;
        }

        // 找到大于降序元素的，元素, 然后两个元素进行互换
        if i != 0 {
            let mut j = length - 1;
            while j > 0 && nums[j] <= nums[i - 1] {
                j -= 1;
            }

            nums.swap(i-1, j);
        }

        // 对降序元素下标后面的元素，进行升序排序
        let mut left = i;
        let mut right = length - 1;
        while left < right {
            nums.swap(left, right);
            left += 1;
            right -= 1;
        }
    }
}
```

## 32 最长有效括号

```
栈、字符串、动态规划
```

题解:

![image](https://github.com/user-attachments/assets/bded8ec8-fe86-443b-bba4-f7e9c95827cd)

![image](https://github.com/user-attachments/assets/1918ef1c-71e1-457e-af7f-bf4d7981bffa)

![image](https://github.com/user-attachments/assets/90f79034-4360-453e-9ded-b1bfddfda913)

![image](https://github.com/user-attachments/assets/51372ecc-0bc3-4215-afd2-6db6ff506874)

![image](https://github.com/user-attachments/assets/ddb065bd-7bcc-4371-b53c-8bf905310274)

![image](https://github.com/user-attachments/assets/434d35a3-aca2-4b39-8911-1b9495255713)

![image](https://github.com/user-attachments/assets/3e29f487-a705-43d8-8552-32dad7483703)

![image](https://github.com/user-attachments/assets/71a60b33-6ce2-40ec-8661-1ab9b6a686f9)

![image](https://github.com/user-attachments/assets/7bf0eb66-381d-4e2a-8322-22ecfa9ca944)

![image](https://github.com/user-attachments/assets/a8e9fac0-ecd9-448e-b618-1e45c54ca095)

![image](https://github.com/user-attachments/assets/6c693964-c41a-4d2d-9300-d8b8411ea493)

![image](https://github.com/user-attachments/assets/d8b2edf6-4904-4b56-adce-2fb7fc17b8ec)

Python
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        """
        最长连续有序括号
        利用栈来判断括号的有序性

        遇到 "(" 入栈，下标入栈
        遇到 ")", 先弹出栈顶元素，
            -- 如果栈为空，说明当前右括号为没有被匹配的右括号，将该右括号的下标加入栈中
            -- 栈不为空，则 当前下标 - 栈顶元素(下标) = 当前最长有序括号的长度
        :param s:
        :return:
        """
        n = len(s)
        stack = [-1]
        res = 0
        for i in range(n):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    res = max(res, i - stack[-1])

        return res
```

Rust:
```rust
impl Solution {
    pub fn longest_valid_parentheses(s: String) -> i32 {
        let mut stack = vec![-1 as i32];
        let mut max_length = 0;

        for (i, c) in s.chars().enumerate() {
            if c == '(' {
                stack.push(i as i32);
            } else {
                stack.pop();
                if stack.is_empty() {
                    stack.push(i as i32);
                } else {
                    let temp = i as i32 - (stack[stack.len() - 1]) as i32;
                    max_length = max_length.max(temp);
                }
            }
        }

        max_length as i32
    }
}
```

## 33. 搜索旋转排序数组

```
数组、二分查找
```

题解：

![image](https://github.com/user-attachments/assets/2f260765-4dab-42e2-b9fa-ec81c3555990)

![image](https://github.com/user-attachments/assets/e35d454e-ba22-4d25-a207-3a7320637c3a)

Pyhton:
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        """
        因为数组是经过旋转过后的
        :param nums:
        :param target:
        :return:
        """
        if not nums:
            return -1
    
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[0] <= nums[mid]:
                if nums[0] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[len(nums) - 1]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

Rust:
```rust
impl Solution {
    pub fn search(nums: Vec<i32>, target: i32) -> i32 {
        if nums.is_empty() {
            return -1 as i32
        }
        let mut left = 0;
        let mut right = nums.len() - 1;

        while left <= right {
            let mid = (left + right) / 2;
            if target == nums[mid] {
                return mid as i32;
            }

            if nums[0] <= nums[mid] {
                if nums[0] <= target && target < nums[mid] {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if nums[mid] < target && target <= nums[nums.len() - 1] {
                    left = mid + 1;
                } else {
                    right = mid - 1
                }
            }
        }
        -1 as i32
    }
}
```

## 34. 在排序数组中查找元素的第一位和最后一位

```
数组、二分查找
```

Python:
```python
def search_range(nums, target):
    """
    解放1
    利用两个二分，分别找出left_border，right_border
    然后在分三种情况：
    情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
    情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
    情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}


    解法2
    先利用二分查找，找到target元素
    然后在寻找，左右边界


    解法3
    1、首先，在 nums 数组中二分查找得到第一个大于等于 target的下标（左边界）与第一个大于target的下标（右边界）；
    2、如果左边界<= 右边界，则返回 [左边界, 右边界]。否则返回[-1, -1]


    解法4
    1.首先，在nums数组中二分查找得到第一个大于等于target的下标leftBorder
    2.在 nums 数组中二分查找得到第一个大于等于 target + 1 的下标，减1则得到rightBorder
    3.如果开始位置在数字的右边或者不存在target，则返回[-1, -1]，否则返回[leftBorder, rightBorder]
    """


    # # 解法1
    # def get_right_border(nums, target):
    #     left, right = 0, len(nums) - 1
    #     right_border = -2
    #     while left <= right:
    #         mid = left + (left + right) // 2
    #         if nums[mid] > target:
    #             right = mid - 1
    #         else:  # 寻找右边界，nums[middle] == target的时候更新left
    #             left = mid + 1
    #             right_border = left
    #     return right_border
    #
    # def get_left_border(nums, target):
    #     left, right = 0, len(nums) - 1
    #     left_border = -2
    #     while left <= right:
    #         mid = left + (left + right) // 2
    #         if nums[mid] >= target:
    #             right = mid - 1
    #             left_border = right
    #         else:
    #             left = mid + 1
    #     return left_border
    # left_border = get_left_border(nums, target)
    # right_border = get_right_border(nums, target)
    # # 情况1
    # if left_border == -2 or right_border == -2:
    #     return [-1, -1]
    # # 情况3
    # if right_border - left_border > 1:
    #     return [left_border+1, right_border-1]
    # # 情况2
    # return [-1, -1]


    # # 解法2
    # def binary_search(nums, target):
    #     left, right = 0, len(nums) - 1
    #     while left <= right:
    #         mid = left + (right - left) // 2
    #         if nums[mid] > target:
    #             right = mid - 1
    #         elif nums[mid] < target:
    #             left = mid + 1
    #         else:
    #             return mid
    #     return -1
    #
    # index = binary_search(nums, target)
    # if index == -1:return [-1, -1]
    # left, right = index
    # # 寻找左边界
    # while left - 1 >= 0 and nums[left - 1] == target:left -= 1
    # while right + 1 < len(nums) and nums[right + 1] == target:right += 1
    # return [left, right]


    # # 解法3
    # def binary_search(nums2, target2, lower):
    #     left, right = 0, len(nums2) - 1
    #     ans = len(nums2)
    #     while left <= right:  # 不变量： 左闭右闭区间
    #         mid = left + (left + right) // 2
    #         if nums2[mid] > target2 or (lower and nums2[mid] >= target2):
    #             right = mid - 1
    #             ans = mid
    #         else:
    #             left = mid + 1
    #     return ans
    #
    # left_border = binary_search(nums, target, True)  # 搜索左边界
    # right_border = binary_search(nums, target, False) - 1  # 搜索右边界
    # if left_border <= right_border and right_border < len(nums) and nums[right_border] == target and nums[left_border] == target:
    #     return [left_border, right_border]
    # return [-1, -1]


    # # 解法4
    # def binary_search(nums4, target4):
    #     left = 0
    #     right = len(nums4)-1
    #     while left <= right:
    #         mid = left + (left + right)//2
    #         if nums4[mid] >= target4:
    #             right = mid - 1
    #         else:
    #             left = mid + 1
    #
    #     return left
    # left_border = binary_search(nums, target)
    # right_border = binary_search(nums, target + 1) - 1
    # if left_border == len(nums) or nums[left_border] != target:
    #     return [-1, -1]
    # return [left_border, right_border]
```

Rust:
```rust
impl Solution {
    fn binary_search(nums: &[i32], target: i32) -> i32 {
        let mut left = 0;
        let mut right = nums.len() as i32 - 1;

        while left <= right {
            let mid = left + (right - left) / 2;
            if nums[mid as usize] > target {
                right = mid - 1;
            } else if nums[mid as usize] < target {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        -1
    }

    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let index = Solution::binary_search(&nums, target);
        if index == -1 {
            return vec![-1, -1];
        }

        let mut left = index;
        let mut right = index;

        // 寻找左边界
        while left > 0 && nums[(left - 1) as usize] == target {
            left -= 1;
        }

        // 寻找右边界
        while right + 1 < nums.len() as i32 && nums[(right + 1) as usize] == target {
            right += 1;
        }

        vec![left, right]
    }
}
```

## 35. 搜索插入位置

```
数组、二分查找
```

Python:
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        
        return left
```

## 36. 有效数独

```
数组、哈希表、矩阵
```

题解：
使用3个boolean二维数组
row[i][num]：代表，第几行的num数字是否存在
col[i][num]: 代表，第几列的num数字是否存在
block[b][num]: 代表，第几块方格的num数字是否存在

0：代表False
1：代表True

- step1: 利用三个二维数组，分别表示行、列、小方格
- step2: 开始遍历数独矩阵，遍历到的元素，判断是否位1-9
- step3: 判断是否在行、列、小方格哈希表中存在
- step4: 如果存在 return False
- step5: 遍历完数独矩阵后，没有问题，则 return True

Python
```python
  class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        """
        使用3个boolean二维数组
        row[i][num]：代表，第几行的num数字是否存在
        col[i][num]: 代表，第几列的num数字是否存在
        block[b][num]: 代表，第几块方格的num数字是否存在

        0：代表False
        1：代表True
        :param self:
        :param board:
        :return:
        """
        row = [[0] * 9 for _ in range(9)]  # 表示行的二维数组
        col = [[0] * 9 for _ in range(9)]  # 表示列的二维数组
        block = [[0] * 9 for _ in range(9)]  # 表示3 * 3的二维数组

        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    num = int(board[i][j]) - 1
                    b = (i // 3) * 3 + (j // 3)  # 计算在第几块方格
                    if row[i][num] or col[j][num] or block[b][num]:
                        return False
                    row[i][num] = col[j][num] = block[b][num] = 1

        return True
```

Rust:
```rust
impl Solution {
    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {
        let mut row = vec![vec![false; 9]; 9];
        let mut col = vec![vec![false; 9]; 9];
        let mut block  = vec![vec![false; 9]; 9];

        for i in 0..9 {
            for j in 0..9 {
                let num = board[i][j] as usize - '1' as usize;
                if num < 9 {
                    let b = (i / 3) * 3 + (j / 3);
                    if row[i][num] || col[j][num] || block[b][num] {
                        return false
                    }
                    row[i][num] = true;
                    col[j][num] = true;
                    block[b][num] = true;
                }
            }
        }

        true
    }
}
```

## 37. 解数独

```
数组、哈希表、回溯、矩阵
```

题解：（回溯 + 状态压缩）
step1：状态压缩

![image](https://github.com/user-attachments/assets/d68cc7f1-07e2-45c5-902f-2c0a4acffb51)

step2: 回溯

![image](https://github.com/user-attachments/assets/b873b49f-bded-46f9-aa58-538cce979a67)

图解：

![image](https://github.com/user-attachments/assets/49a7c120-8edd-4030-9f2f-51077c315ee3)


Python:
```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        """
        回溯 + 状态压缩
        Do not return anything, modify board in-place instead.
        """
    
        # 计算可能的数字
        def get_possible_digits(r, c):
            """
            计算压缩状态
            例如：
            rows[4]:  1, 0, 1, 1, 0, 0, 0, 1, 0
            cols[4]:  1, 1, 0, 0, 0, 1, 1, 1, 1
            boxes[3]: 0, 1, 1, 0, 0, 1, 0, 1, 0
            rows[4] | cols[4] | boxes[1][1]:    1, 1, 1, 1, 0, 1, 1, 1
            ~(rows[4] | cols[4] | boxes[1][1]): 0, 0, 0, 0, 1, 0, 0, 0 -> 表示该单元格填入是数字
            :param r: 行号
            :param c: 列号
            :return:
            """
            b = (r // 3) * 3 + (c // 3)
            return [
                i
                for i in range(1, digits + 1)
                if not any(list(zip(rows[r], cols[c], boxes[b]))[i])
            ]
    
        # 选择能填的数字最少的格子，从这样的格子开始填，填错的概率最小，回溯次数也会变少。
        def get_next_cell():
            r, c, min_count = 0, 0, digits + 1
            for i in range(m):
                for j in range(n):
                    if board[i][j] == ".":
                        possible_digits = get_possible_digits(i, j)
                        if len(possible_digits) < min_count:
                            min_count = len(possible_digits)
                            r, c = i, j
            return r, c
    
        # 填写单元格
        def toggle_an_cell(r, c, num, used):
            b = (r // 3) * 3 + (c // 3)
            rows[r][num] = cols[c][num] = boxes[b][num] = used
            board[r][c] = str(num) if used else "."
    
        # 递归调用
        def backtrack(remaining):
            if remaining == 0:
                return True
            r, c = (
                get_next_cell()
            )  # 选择能填的数字最少的格子，从这样的格子开始填，填错的概率最小，回溯次数也会变少。
            possible_digits = get_possible_digits(r, c)  # 计算可能的数字
            for pd in possible_digits:
                toggle_an_cell(r, c, pd, used=True)  # 填充单元格
                if backtrack(remaining - 1):  # 递归
                    return True
                toggle_an_cell(r, c, pd, used=False)  # 回溯
            return False
    
        digits = 9
        m, n = len(board), len(board[0])
        remaining = 0
        rows = [[True] + [False] * n for _ in range(m)]
        cols = [[True] + [False] * n for _ in range(n)]
        boxes = [[True] + [False] * n for _ in range(m)]
    
        for r in range(m):
            for c in range(n):
                d = board[r][c]
                if d == ".":
                    remaining += 1
                else:
                    b = (r // 3) * 3 + (c // 3)
                    rows[r][int(d)] = cols[c][int(d)] = boxes[b][int(d)] = True
    
        backtrack(remaining)
        print(board)
```


Rust:
```rust
impl Solution {
    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {
        let digits = 9;
        let m = board.len();
        let n = board[0].len();
        let mut remaining = 0;

        // 初始化行、列和3x3宫格的状态
        let mut rows = vec![vec![false; digits]; m];
        let mut cols = vec![vec![false; digits]; n];
        let mut boxes = vec![vec![false; digits]; m];

        for r in 0..m {
            for c in 0..n {
                let d = board[r][c];
                if d == '.' {
                    remaining += 1;
                } else {
                    if let Some(num) = d.to_digit(10) {
                        let b = (r / 3) * 3 + (c / 3);
                        let num = (num - 1) as usize;
                        rows[r][num] = true;
                        cols[c][num] = true;
                        boxes[b][num] = true;                        
                    } else {
                        println!("{} is not a valid digit", d);
                    }

                }
            }
        }

        Solution::backtrack(board, &mut rows, &mut cols, &mut boxes, remaining);
    }

    fn backtrack(
        board: &mut Vec<Vec<char>>,
        rows: &mut Vec<Vec<bool>>,
        cols: &mut Vec<Vec<bool>>,
        boxes: &mut Vec<Vec<bool>>,
        remaining: usize,
    ) -> bool {
        if remaining == 0 {
            return true;
        }
        let (r, c) = Solution::get_next_cell(board, rows, cols, boxes);
        let possible_digits = Solution::get_possible_digits(r, c, rows, cols, boxes);

        for &pd in &possible_digits {
            Solution::toggle_an_cell(board, rows, cols, boxes, r, c, pd, true);
            if Solution::backtrack(board, rows, cols, boxes, remaining - 1) {
                return true;
            }
            Solution::toggle_an_cell(board, rows, cols, boxes, r, c, pd, false);
        }

        false
    }

    fn get_next_cell(
        board: &Vec<Vec<char>>,
        rows: &Vec<Vec<bool>>,
        cols: &Vec<Vec<bool>>,
        boxes: &Vec<Vec<bool>>,
    ) -> (usize, usize) {
        let mut min_count = 10;
        let mut r = 0;
        let mut c = 0;

        for i in 0..rows.len() {
            for j in 0..cols.len() {
                if board[i][j] == '.' {
                    let possible_digits = Solution::get_possible_digits(i, j, rows, cols, boxes);
                    if possible_digits.len() < min_count {
                        min_count = possible_digits.len();
                        r = i;
                        c = j;
                    }                    
                }
            }
        }

        (r, c)
    }

    fn get_possible_digits(
        r: usize,
        c: usize,
        rows: &Vec<Vec<bool>>,
        cols: &Vec<Vec<bool>>,
        boxes: &Vec<Vec<bool>>,
    ) -> Vec<usize> {
        let mut possible_digits = Vec::new();
        let b = (r / 3) * 3 + (c / 3);

        for num in 0..9 {
            if !rows[r][num] && !cols[c][num] && !boxes[b][num] {
                possible_digits.push(num);
            }
        }

        possible_digits
    }

    fn toggle_an_cell(
        board: &mut Vec<Vec<char>>,
        rows: &mut Vec<Vec<bool>>,
        cols: &mut Vec<Vec<bool>>,
        boxes: &mut Vec<Vec<bool>>,
        r: usize,
        c: usize,
        num: usize,
        used: bool,
    ) {
        let b = (r / 3) * 3 + (c / 3);
        rows[r][num] = used;
        cols[c][num] = used;
        boxes[b][num] = used;
        board[r][c] = if used { (num + 1).to_string().chars().next().unwrap() } else { '.' };
    }
}
```

## 38. 外观数列

```
字符串、递归
```

Python:
```python
class Solution:
    def countAndSay(self, n: int) -> str:
        """
        递归方法
        """
        def backtrack(n):
            """
            递归
            """
            if n == 1:
                return "1"

            rle = backtrack(n - 1)
            res = ''  # 结果
            temp = rle[0]  # 临时结果
            count = 0  # 出现次数
            for c in str(rle):
                ## 计算出现次数
                if temp == c:
                    count += 1
                else:
                    res = res + str(count) + temp
                    temp = c
                    count = 1

            res = res + str(count) + temp
            return res

        # 递归调用
        return backtrack(n)
```

Rust:
```rust
impl Solution {
    pub fn count_and_say(n: i32) -> String {
         Solution::backtrack(n)       
    }

    fn backtrack(n: i32) -> String {
        if n == 1 {
            return "1".to_string();
        }

        let prev = Solution::backtrack(n - 1);
        let mut res = String::new();
        let mut temp = prev.chars().next().unwrap();
        let mut count = 0;
        for c in prev.chars() {
            if temp == c {
                count += 1;
            } else {
                res.push(count.to_string().chars().next().unwrap());
                res.push(temp);
                temp = c;
                count = 1
            }
        }

        res.push(count.to_string().chars().next().unwrap());
        res.push(temp);
        res
    }
}
```

## 39. 组合总和

```
递归 + 回溯
```

```
回溯三部曲
-- 递归函数参数
-- 递归终止条件
-- 单层搜索的逻辑
```

![image](https://github.com/user-attachments/assets/f33ea161-7c0a-475c-bdb8-f96d19e3cc11)

Python
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        """
        递归 + 回溯
        :param candidates: 
        :param target: 
        :return: 
        """
        candidates = sorted(candidates)
        temp = []
        path = []

        def dfs(index, t):
            if t == 0:
                path.append(temp.copy())
                return

            if t < candidates[index]:  # t < candidates[index] 提前判断
                return

            for i in range(index, len(candidates)):
                temp.append(candidates[i])
                if t >= candidates[i]:  # 进行判断，剪枝
                    dfs(i, t - candidates[i])  # 递归
                temp.pop()  # 回溯

        dfs(0, target)
        return path
```

Rust:
```rust
impl Solution {
    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut candidates = candidates;
        candidates.sort();
        let mut result = Vec::new();
        let mut current_combination = Vec::new();
        Solution::backtrack(&candidates, target, 0, &mut current_combination, &mut result);
        result
    }

    fn backtrack(
        candidates: &[i32],
        target: i32,
        start: usize,
        current_combination: &mut Vec<i32>,
        result: &mut Vec<Vec<i32>>,
    ) {
        if target == 0 {
            result.push(current_combination.clone());
            return;
        }

        for i in start..candidates.len() {
            if candidates[i] > target {
                break;
            }
            current_combination.push(candidates[i]);
            Solution::backtrack(candidates, target - candidates[i], i, current_combination, result);
            current_combination.pop();
        }
    }
}
```

## 40. 组合总和Ⅱ

```
数组、回溯
```

题解：
该题与组合总和相识，区别在与，组合结果不重复，数组的中的元素只能使用一次

该题解决所在：去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。

Python
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        """
        递归 + 回溯
        :param candidates:
        :param target:
        :return:
        """
        candidates = sorted(candidates)
        temp = []
        path = []

        def dfs(index, t):
            if t == 0:
                path.append(temp.copy())
                return

            if t < 0:  # t < 0 提前判断
                return False

            for i in range(index, len(candidates)):
                if i > index and candidates[i] == candidates[i-1]:
                    # 遇到同一树层，相同的元素的树枝，进行剪枝
                    continue

                temp.append(candidates[i])
                if t >= candidates[i]:  # 进行判断，剪枝
                    dfs(i + 1, t - candidates[i])  # 递归
                temp.pop()  # 回溯

        dfs(0, target)
        print(path)
        return path
```

Rust
```rust
impl Solution {
    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut candidates = candidates;
        candidates.sort();
        let mut result = Vec::new();
        let mut current_combination = Vec::new();
        Solution::backtrack(&candidates, target, 0, &mut current_combination, &mut result);
        result
    }

    fn backtrack(
        candidates: &[i32],
        target: i32,
        start: usize,
        current_combination: &mut Vec<i32>,
        result: &mut Vec<Vec<i32>>,
    ) {
        if target == 0 {
            result.push(current_combination.clone());
            return;
        }

        if target < 0 {
            return;
        }

        for i in start..candidates.len() {
            if i > start && candidates[i] == candidates[i-1] {
                // 剪枝, 剪掉相同元素的同一层树的树枝
                continue;
            }
            current_combination.push(candidates[i]);
            Solution::backtrack(candidates, target - candidates[i], i + 1, current_combination, result);
            current_combination.pop();
        }
    }
}
```

## 41. 缺少的第一个正数

```
数组，哈希表
```

题解：

![image](https://github.com/user-attachments/assets/8d5fddd2-023d-4d86-bfe4-c4b3749bd850)

![image](https://github.com/user-attachments/assets/39c33d99-dc98-4374-b16b-a7bff8620007)

![image](https://github.com/user-attachments/assets/1b5f373d-28f9-41e8-8c89-5662e72ed9b9)

![image](https://github.com/user-attachments/assets/4ee46b8e-b52e-4f90-940d-e965343c80b0)


Python:
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        """
        原地哈希， 将数组设计成哈希表(打标记)
        res总是在[1, N + 1]里，N：为数组长度

        step1: 将 <=0的数 转化为为N + 1
        step2：将 <= N 的元素对应位置的元素打上标记(负号)，负号标记表示 该下标数(该数) 出现过
        step3：返回第一个大于零的元素的下标+1
        :param nums:
        :return:
        """
        length = len(nums)
        for i in range(length):
            if nums[i] <= 0:
                nums[i] = length + 1

        for j in range(length):
            num = abs(nums[j])
            if length >= num:
                nums[num - 1] = -abs(nums[num - 1])

        for z in range(length):
            if nums[z] > 0:
                return z + 1
        
        return length + 1
```

## 42. 接雨水

```
栈、数组、双指针、动态规划、1+
```

题解1（动态规划）：

![image](https://github.com/user-attachments/assets/f5abe88a-57dd-448c-aee3-8adee3f90992)

![image](https://github.com/user-attachments/assets/a3effce3-0854-47b3-ac90-ae34fb98300f)

![image](https://github.com/user-attachments/assets/2851ab4c-04c0-4e88-9d0c-6df964fca3ac)


Python
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """
        动态规划
        
        step1: 先用两个list，leftMax(储存每个位置的左边最高柱子)，rightMax(储存每个位置的右边最高柱子)
        step2: 然后通过 min(rightMax[i] - leftMax[i]) - height 计算接水量
        """
        if not height:
            return 0
        
        n = len(height)
        leftMax = [height[0]] + [0] * (n - 1)
        for i in range(1, n):
            # leftMax(储存每个位置的左边最高柱子)
            leftMax[i] = max(leftMax[i - 1], height[i])
        
        rightMax = [0] * (n - 1) + [height[n - 1]]
        for i in range(n - 2, -1, -1):
            # rightMax(储存每个位置的右边最高柱子)
            rightMax[i] = max(rightMax[i + 1], height[i])
        
        # in(rightMax[i] - leftMax[i]) - height 计算接水量
        ans = sum(min(leftMax[i], rightMax[i]) - height[i] for i in range(n))
        return ans
```

题解2（单调栈）

![image](https://github.com/user-attachments/assets/31e03cf3-3bdb-4939-b60b-b0d335b40f05)

![image](https://github.com/user-attachments/assets/9080dc11-749b-493c-9f08-030fe8056cca)

![image](https://github.com/user-attachments/assets/48ae6822-0192-45d0-813c-914f936775d9)

![image](https://github.com/user-attachments/assets/0ec123c6-90a2-4eef-bf8b-dbfda896c8b2)

![image](https://github.com/user-attachments/assets/c49bc631-6381-4d17-b69c-2b6dea63f13a)

![image](https://github.com/user-attachments/assets/33715fba-8e54-46c4-9c28-53d1073221b9)

![image](https://github.com/user-attachments/assets/bacad89e-2661-461a-b29b-48b29ae2455f)


Python:
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 单调栈
        # step1: 循环height数组，定义一个栈(储存柱子的下标)
        # step2: 当栈不为空时，当前 h 大于栈顶对应元素时，栈顶元素出栈，开始计算接水量
        # step3：计算接水量，获取栈顶的下标对应的元素（为left）
        # step4：i：当前下标，curr_width = i - left - 1，curr_height = min(height[left], height[i]) - height[top]
        ans = 0
        stack = list()
        n = len(height)

        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                curr_width = i - left - 1
                curr_height = min(height[left], height[i]) - height[top]
                ans += curr_width * curr_height
            
            stack.append(i)
        
        return ans
```

题解3（双指针）

![image](https://github.com/user-attachments/assets/13c3ae70-0335-4d20-b0ac-025e5d201fa9)

![image](https://github.com/user-attachments/assets/76f8ba7a-92b1-480a-88e2-adef371a0a40)

![image](https://github.com/user-attachments/assets/ecf2c9d5-6cf2-4ae1-922e-f354d2801425)

![image](https://github.com/user-attachments/assets/4ac24109-d459-4255-ad77-7cf2b1d48a8d)

![image](https://github.com/user-attachments/assets/201221af-7e50-4cc0-ba7f-bacd61ee1eb0)

![image](https://github.com/user-attachments/assets/ae0c3976-7fed-476f-991a-6067a70b1d20)

![image](https://github.com/user-attachments/assets/4fd6e0fb-f7a0-4acb-925b-8d8a278b856f)

Python
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 双指针
        ans = 0
        left, right = 0, len(height) - 1  # 定义两个指针，left，right
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans
```

## 43. 字符串相乘

```
数学、字符串、模拟
```

题解1（做加法）

![image](https://github.com/user-attachments/assets/c5d79c26-8d9b-4f2c-a6b3-ad7a8eefc297)

Pyhton:
```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"

        ans = "0"  # 结果
        m, n = len(num1), len(num2)
        for i in range(n - 1, -1, -1):
            add = 0  # 进位
            y = int(num2[i])
            curr = ["0"] * (n - i - 1)  # 当前数的数组, 通过 n - i - 1 计算有多少个零位
            for j in range(m - 1, -1, -1):
                product = int(num1[j]) * y + add
                curr.append(str(product % 10))  # 计算余位
                add = product // 10  # 计算进位
            if add > 0:
                # 如果是最后一个进位，加入当前数的数组中
                curr.append(str(add))

            curr = "".join(curr[::-1])  # 将当前数的数组进行反转
            ans = self.addString(ans, curr)
        return ans

    def addString(self, num1, num2):
        i, j = len(num1) - 1, len(num2) - 1
        add = 0  # 进位
        ans = list()  # 结果
        while i >= 0 or j >= 0 or add != 0:
            x = int(num1[i]) if i >= 0 else 0
            y = int(num2[j]) if j >= 0 else 0
            result = x + y + add
            ans.append(str(result % 10))  # 计算余位
            add = result // 10  # 计算进位
            i -= 1
            j -= 1
        return "".join(ans[::-1])
```

题解2（做乘法）：

![image](https://github.com/user-attachments/assets/ada8f054-063c-43b0-9b19-a036ed4aab15)

![image](https://github.com/user-attachments/assets/6eec728c-e645-4442-bb55-2a9fa91b2133)

![image](https://github.com/user-attachments/assets/f970094c-8267-4752-9a89-c5b76697fb5e)

![image](https://github.com/user-attachments/assets/ddb85382-142a-47bf-b839-7f34c3849749)

![image](https://github.com/user-attachments/assets/4aec9a48-4fb6-430f-b21c-acaa6976ff2d)

![image](https://github.com/user-attachments/assets/90713487-e9d3-4fcc-b128-a0b86400217a)

![image](https://github.com/user-attachments/assets/c928a1bd-28a4-491a-a14a-85b6ab57cf2a)

![image](https://github.com/user-attachments/assets/76ad3e08-a6e9-4404-b19c-647053169362)


Python:
```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        # 做乘法
        if num1 == "0" or num2 == "0":
            return "0"

        m, n = len(num1), len(num2)
        ans_arr = [0] * (m + n)  # 乘积的结果位数长为 m + n 或 m + n -1

        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ans_arr[i + j + 1] += x * int(num2[j])

        for i in range(m + n - 1, 0, -1):
            ans_arr[i - 1] += ans_arr[i] // 10
            ans_arr[i] %= 10

        index = 1 if ans_arr[0] == 0 else 0
        ans = "".join(str(x) for x in ans_arr[index:])
        return ans
```

## 44. 通配符匹配

```
贪心、递归、字符串、动态规划
```


```
def is_math(s, p):
    if '*' not in p and '_' not in p and len(s) != len(p):
        return False

    def dfs(s_index, p_index):
        if s_index == len(s) and p_index == len(p):
            # 递归出口
            return True

        if s[s_index] == p[p_index] or p[p_index] == '?':
            # 单字符匹配成功
            return dfs(s_index + 1, p_index + 1)
        elif p[p_index] == '*':
            # 多字符匹配
            # 贪心法，先通配最大的字符串，不满足
            temp_start = len(s) - (len(p) - p_index - 1)
            temp_end = s_index
            for i in range(temp_start, temp_end - 1, -1):
                if not dfs(i, p_index + 1):
                    continue
                else:
                    return True
            return False
        else:
            return False

    print(len(s), len(p))
    print(dfs(0, 0))


if __name__ == '__main__':
    is_math("aa", "*")
```

## 45. 跳跃游戏Ⅱ

```
贪心法、数组、动态规划
```

题解（贪心法）：

![image](https://github.com/user-attachments/assets/19951565-2682-486b-b1c6-803874fe06b0)

![image](https://github.com/user-attachments/assets/8b9a50eb-8795-4b23-9173-5364e833e5b6)


Python:
```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        """
        贪心法
    
        如何贪心：
        选择 下一步最远的路径
        :param nums:
        :return:
        """
    
        max_path = 0  # 能跳跃的最大距离
        end_index = 0  # 当前跳跃范围的结束位置
        step_cnt = 0  # 跳跃次数
    
        for i in range(len(nums) - 1):
            max_path = max(max_path, i + nums[i])  # 能跳跃的最大距离，贪心法体现
            if i == end_index:  # 已跳跃到当前跳跃范围的结束范围
                end_index = max_path  # 更新跳跃范围的结束范围
                step_cnt += 1  # 跳跃步数加1
    
        return step_cnt
```

## 46. 全排列

```
数组、回溯
```

题解（递归 + 回溯）：

![image](https://github.com/user-attachments/assets/066af37c-da4f-4ef8-88cd-92cf877a44e3)

思路：

![image](https://github.com/user-attachments/assets/7a568350-6aec-4f55-8a10-c7f741eb0d87)

![image](https://github.com/user-attachments/assets/595b9d18-edb2-4c9a-914d-239c8fe7b9d2)

![image](https://github.com/user-attachments/assets/01954fd2-8bc2-43b4-87bf-907ac4f006fa)

![image](https://github.com/user-attachments/assets/ada36009-2b7e-4d95-8f4d-e6abf87e8828)

![image](https://github.com/user-attachments/assets/13957822-2256-40d6-8ce7-552799545687)

![image](https://github.com/user-attachments/assets/f40963d7-6c36-4aea-ba57-be1223720b3e)

![image](https://github.com/user-attachments/assets/c5c29127-a3ec-4fec-85f7-e0e824c605dc)

![image](https://github.com/user-attachments/assets/2b79a6b0-18fb-448b-8f24-3b15cc246322)


Python:
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        """
        递归 + 回溯

        动态的取维护数组: 
         - 元素在数组内交替互换
         - 递归：遍历数组
         - 回溯：元素交换为原位

        当 index = len(nums) 将单个结果加入结果集合中
        :param nums:
        :return:
        """
        num_len = len(nums)
        n = num_len - 1
        res = []

        def dfs(index):
            if index == n:
                res.append(nums[:])

            for i in range(index, num_len):
                # 动态维护数组
                nums[index], nums[i] = nums[i], nums[index]
                dfs(index + 1)  # 递归
                nums[i], nums[index] = nums[index], nums[i]  # 回溯

        dfs(0)
        return res
```

## 47. 全排列Ⅱ

```
数组、回溯
```
